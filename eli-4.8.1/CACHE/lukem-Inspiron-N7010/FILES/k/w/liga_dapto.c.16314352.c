/* Automatically generated by dapto: DO NOT EDIT */

#ifdef MONITOR
#include <stdio.h>
#include <time.h>
#include <string.h>
#include "liga_dapto.h"


#ifdef PROTO_OK
void _dapto_tree (int root, int parent, int desc)
#else
void _dapto_tree (root, parent, desc)
    int root;
    int parent;
    int desc;
#endif
{
    DAPTO_INIT_EV;
    DAPTO_RESULT_STR ("tree");
    DAPTO_RESULT_LONGVAL (clock ());
#ifdef DAPTO_RESULT_INT
    DAPTO_RESULT_INT (root);
#else
    DAPTO_RESULT_OTHER (root);
#endif
#ifdef DAPTO_RESULT_INT
    DAPTO_RESULT_INT (parent);
#else
    DAPTO_RESULT_OTHER (parent);
#endif
#ifdef DAPTO_RESULT_INT
    DAPTO_RESULT_INT (desc);
#else
    DAPTO_RESULT_OTHER (desc);
#endif
    DAPTO_RESULT_SEND (0);
}

#ifdef PROTO_OK
void get_abs_prodsCmd (char *args)
#else
void get_abs_prodsCmd (args)
    char *args;
#endif
{
    DAPTO_ARG_INIT_OP;
    DAPTO_INIT_OP;
/* #line 38 "/home/lukem/Dropbox/CAS/eli-4.8.1/CACHE/lukem-Inspiron-N7010/FILES/k/v/liga.dapto.16211162.cpp" */
{
    char **s;
    extern char *abs_prods[];
    
    for (s = abs_prods; *s != (char *) 0; s++)
	DAPTO_RESULT_STR (*s);
}
    DAPTO_RESULT_SEND (1);
}

#ifdef PROTO_OK
void get_all_nodesCmd (char *args)
#else
void get_all_nodesCmd (args)
    char *args;
#endif
{
    int root;
    DAPTO_ARG_INIT_OP;
    DAPTO_ARG_INT (&root);
    DAPTO_INIT_OP;
/* #line 48 "/home/lukem/Dropbox/CAS/eli-4.8.1/CACHE/lukem-Inspiron-N7010/FILES/k/v/liga.dapto.16211162.cpp" */
{
    Obstack obstk;
    NODEPTR *stack, n, c;
    int tos = 0, size = 0, num, i;
    extern int abs_nchild[];
    extern NODEPTR abs_child ELI_ARG((NODEPTR, int));












    obstack_init (&obstk);
    if (tos == size) { obstack_grow (&obstk, (void *) (&MONTblStackArray(root)), sizeof (NODEPTR)); stack = (NODEPTR *) obstack_base (&obstk); tos++; size++; } else stack[tos++] = (NODEPTR) (MONTblStackArray(root));
    while (tos != 0) {
	n = stack[--tos];
	if (n == NULLNODEPTR) {
	    DAPTO_RESULT_INTVAL (0);
	    DAPTO_RESULT_INTVAL (-1);
	    DAPTO_RESULT_INTVAL (0);
	} else {
            DAPTO_RESULT_INT (n->_uid);
            DAPTO_RESULT_INT (n->_prod);
            num = abs_nchild[n->_prod];
            DAPTO_RESULT_INT (num);
            for (i = 1; i <= num; i++) {
                c = abs_child (n, i);
                if (tos == size) { obstack_grow (&obstk, (void *) (&c), sizeof (NODEPTR)); stack = (NODEPTR *) obstack_base (&obstk); tos++; size++; } else stack[tos++] = (NODEPTR) (c);
            }
	}
    }
    stack = (NODEPTR *) obstack_finish (&obstk);
    obstack_free (&obstk, (void *) stack);
}
    DAPTO_RESULT_SEND (1);
}

#ifdef PROTO_OK
void get_nodeCmd (char *args)
#else
void get_nodeCmd (args)
    char *args;
#endif
{
    int node;
    DAPTO_ARG_INIT_OP;
    DAPTO_ARG_INT (&node);
    DAPTO_INIT_OP;
/* #line 91 "/home/lukem/Dropbox/CAS/eli-4.8.1/CACHE/lukem-Inspiron-N7010/FILES/k/v/liga.dapto.16211162.cpp" */
{
    NODEPTR nodept;
    int i;
    extern int abs_nchild[];
    extern NODEPTR abs_child ELI_ARG((NODEPTR, int));

    nodept = MONTblStackArray(node);
    DAPTO_RESULT_INT (nodept->_prod);
    for (i = 1; i <= abs_nchild[nodept->_prod]; i++) {
         DAPTO_RESULT_INTVAL ((abs_child (nodept, i))->_uid);
    }
}
    DAPTO_RESULT_SEND (1);
}

#ifdef PROTO_OK
void get_node_coordsCmd (char *args)
#else
void get_node_coordsCmd (args)
    char *args;
#endif
{
    int node;
    DAPTO_ARG_INIT_OP;
    DAPTO_ARG_INT (&node);
    DAPTO_INIT_OP;
/* #line 106 "/home/lukem/Dropbox/CAS/eli-4.8.1/CACHE/lukem-Inspiron-N7010/FILES/k/v/liga.dapto.16211162.cpp" */
{
    NODEPTR nodept;

    nodept = MONTblStackArray(node);
    DAPTO_RESULT_INT (LineOf (nodept->_coord));
    DAPTO_RESULT_INT (CumColOf (nodept->_coord));
    DAPTO_RESULT_INT (RLineOf (nodept->_coord));
    DAPTO_RESULT_INT (RCumColOf (nodept->_coord));
}
    DAPTO_RESULT_SEND (1);
}

#ifdef PROTO_OK
void find_nodesCmd (char *args)
#else
void find_nodesCmd (args)
    char *args;
#endif
{
    int root;
    int line;
    int col;
    DAPTO_ARG_INIT_OP;
    DAPTO_ARG_INT (&root);
    DAPTO_ARG_INT (&line);
    DAPTO_ARG_INT (&col);
    DAPTO_INIT_OP;
/* #line 119 "/home/lukem/Dropbox/CAS/eli-4.8.1/CACHE/lukem-Inspiron-N7010/FILES/k/v/liga.dapto.16211162.cpp" */
{
    NODEPTR n, ch, save;
    int i, l1, c1, l2, c2;
    extern int abs_nchild[];
    extern NODEPTR abs_child ELI_ARG((NODEPTR, int));
	
    DAPTO_RESULT_INT (root);
    n = MONTblStackArray(root);
    do {
	save = n;
	for (i = 1; i <= abs_nchild[n->_prod]; i++) {
	    ch = abs_child (n, i);
	    if (ch == NULLNODEPTR)
		continue;
	    l1 = LineOf (ch->_coord);
   	    c1 = CumColOf (ch->_coord);
	    l2 = RLineOf (ch->_coord);
	    c2 = RCumColOf (ch->_coord);
	    if ((((line == l1) && (col >= c1)) || (line > l1)) &&
		(((line == l2) && (col <= c2)) || (line < l2))) {
	        DAPTO_RESULT_INT (ch->_uid);
	        n = ch;
		break;
	    }
	}
    } while (n != save);
}
    DAPTO_RESULT_SEND (1);
}

void _dap_liga_init ()
{
    _dap_add_command ("get_abs_prods", get_abs_prodsCmd );
    _dap_add_command ("get_all_nodes", get_all_nodesCmd );
    _dap_add_command ("get_node", get_nodeCmd );
    _dap_add_command ("get_node_coords", get_node_coordsCmd );
    _dap_add_command ("find_nodes", find_nodesCmd );
}
#else
static int _dapto; /* To avoid messages about empty files. */
#endif
