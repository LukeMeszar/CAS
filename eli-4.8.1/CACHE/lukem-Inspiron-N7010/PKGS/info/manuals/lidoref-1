This is Info file lidoref, produced by Makeinfo-1.43 from the input
file /home/lukem/Dropbox/CAS/eli-4.8.1/Eli/pkg/liga/Info/lidoref.tnf.


File: lidoref,  Node: top,  Up: (dir)

LIDO - Reference Manual
***********************

$Revision: 4.34 $

This is a reference manual for LIDO, a language for the specification
of computations in trees. It is used to specify all computations of
the analysis phase and the translation phase of a language processor,
which are to be executed on the abstract tree. The main purpose of a
LIDO specification is to describe which computations have to be
executed in which tree context, how those computations depend on each
other, and which values are propagated from one computation to
another. The functions called in computations and the types of
propagated values are implemented in C; those implementations are not
part of a LIDO specification.

* Menu:

* Introduction::
* Overall Structure::
* Rule Specifications::
	* Productions::
* Symbol Specifications::
* Computations::
        * Attribute Computations and Plain Computations::
        * Accumulating Computations::
* Attributes::
	* Types and Classes of Attributes::
* Expressions::
	* Dependent Expressions::
	* Terminal Access::
	* Simple Expressions::
* Inheritance of Computations::
* Remote Attribute Access::
	* INCLUDING::
	* CONSTITUENT(S)::
	* CHAIN::
* Computed Subtrees::
	* Tree Construction Functions::
* Iterations::
* Predefined Entities::
* Outdated Constructs::
* Syntax::
* Index::


File: lidoref,  Node: Introduction,  Next: Overall Structure,  Up: top

Introduction
************

This is a reference manual for LIDO, a language for the specification
of computations in trees. It is used to specify all computations of
the analysis phase and the translation phase of a language processor,
which are to be executed on the abstract tree. The main purpose of a
LIDO specification is to describe which computations have to be
executed in which tree context, how those computations depend on each
other, and which values are propagated from one computation to
another. The functions called in computations and the types of
propagated values are implemented in C; those implementations are not
part of a LIDO specification.

The LIGA system processes a LIDO specification and generates an
evaluator in form of a C module from it. LIGA automatically determines
a tree walk strategy and the evaluation order of computations on the
base of the specified dependencies.  Attribute grammars are the formal
model for this process.

This document is intended to provide precise definitions of LIDO
constructs and of rules of the language LIDO. For studying the use of
LIDO in more complex and complete translation specifications we
recommend to read the explained example specifications in
$/Name/Examples/AlgLike.fw and in $/Type/Examples/Type.fw.

Other documents related to LIDO are:

     * LIDO - Computation in Trees: (comptrees).
     introduces and explains typical uses of LIDO constructs.
     
     * LIGA - Control Language: (lcl).
     describes how variants in LIGA's processing can
     be controlled.
     
     * Show: (show).
     describes how to obtain debugging information for LIDO.
     
     * GORTO - Graphical Order Tool: (gorto).
     describes how to trace dependencies graphically.
     
     * ModLib - Specification Module Library: (modlib).
     describes how to use precoined solutions of common problems.


File: lidoref,  Node: Overall Structure,  Next: Rule Specifications,  Prev: Introduction,  Up: top

Overall Structure
*****************

A LIDO text specifies an evaluator for executing computations driven
by a tree walk. A tree grammar specifies the structure of trees. 
Computations are associated with rules and symbols of the tree
grammar. Computations may depend on one another via typed attributes.

In Eli a LIDO specification is usually composed of several components
supplied by the user, derived from libraries, or generated by Eli
tools. The components are combined into one file and then processed by
LIGA.

Syntax
......

         LIDOSpec       ::=  Specification
         Specification  ::=  Specification Specification |
                          |  RuleSpec ';' | SymComp ';'
                          |  SymSpec ';'  | TermSpec ';'
                          |  AttrSpec ';' | ChainSpec ';'

Examples
........

         RULE p: Stmt  ::= 'while' Expr 'do' Stmt COMPUTE
           Expr.postType = boolType
         END;
     
         SYMBOL Expr COMPUTE
           Compatible (THIS.preType, THIS.postType);
         END;
     
         ATTR preType, postType: DefTableKey;

There is no restriction on the order of specifications. Any
permutation of specifications has the same meaning.

LIDO objects such as rules, symbols, or attributes are identified by
their names. They are introduced by using them in LIDO constructs.
There are no explicit declarations in LIDO.

Specifications associate certain properties with an object, e. g.
computations are associated with a rule, or a type with an attribute
name. There may be several specifications for the same object as long
as the specified properties are not contradictory.

In the syntax of this document we distinguish names for objects of
different kinds, e. g. `RuleName', `SymbName', `TypeName'. The syntax
rules for names are omitted in the rest of this document. The following
rules are assumed for `XYZNames'

         XYZName  ::= Identifier
         XYZNames ::= XYZName | XYZNames ',' XYZNames

All names are written as identifiers in C.

Restrictions
............

It is strongly recommended *not* to use names that begin with an
underscore or which have the form `rule_i' where i is a number, in
order to avoid interference with identifiers generated by LIGA.

`RuleNames', `SymbNames', and `TypeNames' must be mutually distinct. 
`AttrNames' must be different from `ChainNames'.


File: lidoref,  Node: Rule Specifications,  Next: Symbol Specifications,  Prev: Overall Structure,  Up: top

Rule Specifications
*******************

A rule specification specifies a production of the tree grammar, and
may associate some computations with the rule context. They are
executed in every context which represents that rule in a particular
tree.

The notation of tree grammar productions is described in

* Menu:

* Productions::

Syntax
......

         RuleSpec ::= 'RULE' [RuleName] ':' Production Computations 'END'

Example:
         RULE p: Stmt  ::= 'while' Expr 'do' Stmt COMPUTE
           Expr.postType = boolType
         END;

There may be several rule specifications that refer to the same rule. 
In that case the associated computations are accumulated.

The set of productions of all rules forms the tree grammar. It must
have exactly one root symbol that does not occur on any right-hand
side of a production.

Eli usually generates some rule specifications (without computations)
from the concrete grammar in order to complete the tree grammar.

In general the `RuleName' is omitted. The rule is then identified by
the production. LIGA generates a name of the form `rule_i', with a
unique number `i' for such a rule.  A meaningful `RuleName' should be
specified for rules that are part of computed subtrees, since the name
of the tree construction function is derived from it (*note Computed
Subtrees::.).  Also using the `RuleFct' feature may give rise to
explicitly name rules (*note Predefined Entities::.).

Restrictions
............

Two unnamed rule specifications refer to the same rule if their
productions are identical.

A named rule specification and an unnamed one refer to the same rule if
their productions are identical. In that case there must not be another
rule specification with the same production but a different name.

Two named rule specifications with the same `RuleName' must have the
same production.

Note: Two rule specifications with different names, but equal
productions, are only reasonable if they belong to computed subtrees
rather to subtrees constructed by a parser.


File: lidoref,  Node: Productions,  Up: Rule Specifications

Productions
===========

A production as part of a rule specification describes the structure
of the rule context. Computations associated with the rule may use or
define attributes of nonterminal symbols that occur in the production.
The set of all productions in a LIDO specification defines the tree
grammar.

Syntax
......

         Production     ::= SymbName '::=' Symbols
                          | SymbName 'LISTOF' Elements
     
         Symbols        ::= Symbols Symbols |
                          | SymbName | Literal
     
         Elements       ::=  Elements '|' Elements |
                          | SymbName
     
         TermSpec       ::= 'TERM' SymbNames ':' TypeName

Examples
........

         Stmt ::= 'while' Expr 'do' Stmt
         DefIdent ::= Identifier
         Declarations LISTOF ProcDecl | VarDecl
         TERM Identifier: int;

Productions are composed of nonterminal symbols, named terminal
symbols, and literal terminals.

The `SymbName' on the left-hand side of a production is a nonterminal. 
A `SymbName' that does not occur on the left-hand side of any
production denotes a named terminal. A nonterminal symbol that does
not occur on the right-hand side of any production is the root of the
tree grammar.

We say the rule context is a "lower context" for the left-hand side
nonterminal, and an "upper context" for any right-hand side
nonterminal.

Literal terminals are denoted by arbitrary non empty strings enclosed
in single quotes. A quote that is part of such string is denoted by
two single quotes.

Literal terminals do not contribute to the trees specified by the tree
grammar. They only relate tree productions to concrete productions
describing the input text, and distinguish otherwise equal productions.

Named terminal symbols do not contribute to the trees specified by the
tree grammar. They are related to named terminal symbols of
corresponding concrete productions describing the input text. A value
derived from such an input token may be used in computations which are
associated with the rule of the production or with the symbol on the
left-hand side of the production. (If the tree context is constructed
by a computation, rather than by parsing the input text, then that
value is supplied as an argument to the call of the construction
function (*note Tree Construction Functions::.).)

The type of the value provided by a named terminal symbol is specified
by a `TERM' specification. If there is no such specification the type
`int' is assumed.

There are two forms of productions: plain productions and `LISTOF'
productions.

A plain production defines tree contexts with a node for the left-hand
side nonterminal having a sequence of subtrees, one for each
nonterminal on the right-hand side.

Computations may refer to any attribute of any nonterminal in the
production.  If one nonterminal occurs more than once in the
production references to the occurrences in computations are
distinguished by indices (starting from 1).

A `LISTOF' production defines tree contexts with a node for the
left-hand side nonterminal having an arbitrary long sequence of
subtrees each rooted by a nonterminal specified as a `LISTOF' element.
That sequence may be empty, even if there is no empty `LISTOF' element
specified.

Computations associated with the rule of a `LISTOF' production may only
refer to attributes of the left-hand side symbol. Attributes of the
element subtrees are referenced only by remote attribute access (*note
Remote Attribute Access::.).

Restrictions
............

There must be exactly one root nonterminal which does not occur on any
right-hand side of a tree grammar production.

If `X' is the left-hand side symbol of a `LISTOF' production, then
there may not be a different production (neither `LISTOF' nor plain)
that also has `X' on its left-hand side.

Named terminals may not be `LISTOF' elements.

A literal terminal may not be the empty string.


File: lidoref,  Node: Symbol Specifications,  Next: Computations,  Prev: Rule Specifications,  Up: top

Symbol Specifications
*********************

A symbol specification associates computations with a symbol. They are
executed for every node which represents that symbol in a particular
tree.

Symbols may be introduced which do not occur in the tree grammar. They
are called "`CLASS' symbols" and represent a computational role. 
Their computations may be inherited directly or indirectly by grammar
symbols.  Symbols that do occur in the tree grammar are called "`TREE'
symbols".

Syntax
......

         SymComp    ::= SymbKind SymbName [ Inheritance ] Computations 'END'
     
         SymbKind   ::= 'SYMBOL' | 'CLASS' 'SYMBOL' | 'TREE' 'SYMBOL'

Example:
         TREE SYMBOL Expr COMPUTE
           SYNT.coercion = coerce (THIS.preType, THIS.postType);
           INH.IsValContext = true;
           Compatible (THIS.preType, THIS.postType);
         END;

A symbol specified `TREE' occurs in a tree grammar production, a
symbol specified `CLASS' does not. If neither is specified the symbol
kind is determined by its occurrence in the tree grammar.  (Only the
computations of `CLASS' symbols may be inherited by other symbols.)

The `CLASS' symbol `ROOTCLASS' is predefined.  It is implicitly
inherited by the root of the tree grammar.  Hence, any computation
associated with `ROOTCLASS' is inherited by the root context. This
facility is to be used to specify computational roles for the root
which are grammar independent, and which need not be inherited
explicitly.

Note: There may be `TREE' symbols that do not occur in the user
supplied rules, but only in those generated from the concrete grammar.
In those cases it is recommended to explicitly specify their kind to
be `TREE', in order to get more specific error reports in cases of
accidental mismatches.

Two sets of computations are associated with a symbol: the "lower
computations", which are executed in every lower context of the
symbol, i. e. in a context whose production has the symbol on its
left-hand side, and the "upper computations", which are executed in
every upper context, i. e. in a context whose production has the
symbol on its right-hand side. The upper computations are executed
once for each right-hand side occurrence of the symbol.

Each symbol has two disjoint sets of attributes: "synthesized" (`SYNT')
attributes that are defined by computations in lower contexts of the
symbol, and "inherited" (`INH') attributes that are defined by
computations in upper contexts of the symbol.

In a symbol computation only attributes of that symbol may be used or
defined (except the use of remote attributes).  Those attributes are
denoted `SYNT.a' if `a' is a synthesized attribute, `INH.b' if `b' is
an inherited attribute.  An attribute of the symbol may also be
denoted `THIS.c'.  In this case the attribute class must be specified
in another occurrence of that attribute.

A computation that defines a synthesized (an inherited) attribute of
the symbol belongs to the set of lower (upper) computations.  A "plain
computation" defining no attribute belongs to the set of lower
computations (*note Computations::.).

There may be several symbol specifications for one symbol. In that
case the associated computations are accumulated.

If both a symbol computation and a rule computation define the same
attribute of that symbol, the rule computation will be executed in
that context, overriding the symbol computation.

Plain computations can not be overridden.

Restrictions
............

The kind of a symbol, `TREE' or `CLASS' may not be specified
contradictory.

`CLASS SYMBOL's may not be used in productions.

`TREE SYMBOL's may not be used in `INHERITS' clauses (*note
Inheritance of Computations::.).


File: lidoref,  Node: Computations,  Next: Attributes,  Prev: Symbol Specifications,  Up: top

Computations
************

Computations are associated with rules or with symbols. Each
computation (that is not overridden) is executed exactly once for
every instance of its context in a particular tree. A computation may
yield a value denoted as an attribute which may be used by other
computations.  Computations may also be specified as depending on one
another without passing a value in order to specify dependences on
side-effects of computations.  (*note Dependent Expressions::.).

Syntax
......

         Computations ::=  [ 'COMPUTE' Computation ]
     
         Computation  ::=  Computation Computation |
                        | Attribute '=' Expression Terminator
                        | Expression Terminator
                        | Attribute '+=' Expression Terminator
     
         Terminator   ::= ';'
                        | 'BOTTOMUP' ';'

There are three forms of computations: "attribute computations" denoted
as an assignment to an attribute,  "plain computations" that are
simple expressions, and "accumulating computations" which are a
special variant of attribute computations, distinguished by the `+='
token.

The different forms of computations are described in

* Menu:

* Attribute Computations and Plain Computations::
* Accumulating Computations::


File: lidoref,  Node: Attribute Computations and Plain Computations,  Next: Accumulating Computations,  Up: Computations

Attribute Computations and Plain Computations
=============================================

The following example shows a sequence of two attribute computations
and two plain computations:

Examples
........

         COMPUTE
           Expr.postType = boolType;
           Stmt[1].code = PTGWhile (Expr.code, Stmt[2].code);
           printf ("while loop in line %d\n", LINE);
           printf ("value = %d\n", Expr.val) BOTTOMUP;
         END;

A computation is executed by evaluating its expression. It depends on
every attribute that occurs in the expression regardless whether the
attribute is used for the evaluation. We say those attributes are the
"preconditions" of the computation.  The attribute on the left-hand
side of an attribute computation represents the "postcondition" of
that computation.  Plain computations do not establish a postcondition
for any other computation.  The evaluator is generated such that the
computations are executed in an order that obeys these dependencies
for any tree of the tree grammar.

If both a symbol computation and a rule computation define the same
attribute of a symbol, the rule computation will be executed in that
context, overriding the symbol computation.

An expression may occur in "value context", where it must yield a
value, or it may occur in "`VOID' context", where it may or may not
yield a value.  If it does yield a value in `VOID' context, the value
is discarded.  These terms will be used in sections below where
further constructs are introduced which contain expressions.

If the left-hand side attribute of an attribute computation has a type
different from `VOID' the right-hand side expression is in value
context; the result of the expression evaluation is assigned to the
attribute.  If the left-hand side attribute has the type `VOID' the
right-hand side expression is in `VOID' context.  In this case the
attribute simply states the postcondition that the computation has been
executed.

A plain computation is in `VOID' context, i. e. it may or may not
yield a value.

Computations may be specified to be executed `BOTTOMUP', that means
while the input is being read and the tree is being built.  LIGA then
tries to arrange the computations such that those are executed already
when their tree node is constructed.  This facility is useful for
example if the generated language processor is to produce output while
its input is supplied (like desktop calculators), or if a computation
is used to switch the input file.

Note: A `BOTTOMUP' computation may depend on other computations. 
These dependencies should be specified the usual way. Such
precondition computations should NOT be specified `BOTTOMUP' unless
they themselves are to be related to input processing.  Without such
an over-specification LIGA can apply more sophisticated means to
correctly schedule the precondition computations automatically.

Note: Due to the parser's lookahead, one token beyond the last token
of the context of the `BOTTOMUP' computation is read before before the
computation is executed.

Restrictions
............

If the attribute in an attribute computation has a non-`VOID' type the
evaluation of the expression must yield a value of that type. This
condition is not checked by LIGA. It is checked by the compiler that
compiles the generated evaluator.

Multiple symbol computations that define the same attribute are
forbidden.

There must be exactly one attribute computation for each synthesized
attribute of the left-hand side nonterminal and for each inherited
attribute of each nonterminal occurrence on the right-hand side in the
production of a rule context, or such a computation is inherited in
the rule context.  (For accumulating computations a different rule
applies.)

There may not be any cyclic dependencies between computations for any
tree of the tree grammar.

Contexts that may belong to subtrees which are built by computations
(*note Computed Subtrees::.) may not have computations that are marked
`BOTTOMUP' or contribute to `BOTTOMUP' computations.

LIGA may fail to allocate `BOTTOMUP' computations as required due to
attribute dependencies or due to LIGA's evaluation strategy.  In such
cases messages are given.


File: lidoref,  Node: Accumulating Computations,  Prev: Attribute Computations and Plain Computations,  Up: Computations

Accumulating Computations
=========================

There are situations where a `VOID' attribute, say
`Program.AnalysisDone', represents a computational state which is
reached when several computations are executed, which conceptually
belong to different sections of the LIDO text. Instead of moving all
these computations to the only place where `Program.AnalysisDone' is
computed, several accumulating computations may stay in their
conceptual context and contribute dependences to that attribute.

A computation is marked to be accumulating by the `+=' token.  The
following example demonstrates the above mentioned use of accumulating
computations:
     RULE: Program ::= Statements COMPUTE
        Program.AnalysisDone += DoThis ( );
     END;
       ....
     RULE: Program ::= Statements COMPUTE
        Program.AnalysisDone += DoThat ( ) <- Statements.checked;
     END;
Two accumulating computations contribute both to the attribute
`Program.AnalysisDone', such that it represents the state when the
calls `DoThis ( )' and `DoThat ( )' are executed after the
pre-condition `Statements.checked' has been reached.  The two
accumulating computations above have the same effect as if there was a
single computation, as in
     RULE: Program ::= Statements COMPUTE
        Program.AnalysisDone = ORDER (DoThis ( ), DoThat ( ))
                               <- Statements.checked;
     END;
The order in which `DoThis ( )' and `DoThat ( )' are executed is
arbitrarily decided by the Liga system.

Accumulating computations may be formulated in rule context or in the
context of `TREE' or `CLASS' symbols. Rule attributes may also be
computed by accumulating computations.

Only `VOID' attributes may have accumulating computations.  If an
attribute has an accumulating computation, it is called an
accumulating attribute, and all its computations must be accumulating. 
Attributes are not explicitly defined to be accumulating.  If an
attribute is not defined explicitly, it has the type `VOID' by default. 
Hence, accumulating attributes need not be defined explicitly, at all.

The set of accumulating computations of an attribute is combined into
a single computation, containing all dependences and function calls of
the contributing accumulating computations, as shown above.

Accumulating computations may be inherited from `CLASS' symbols.  In
contrast to non-accumulating computations, there is no hiding for
accumulating computations: All accumulating computations that lie on
an inheritance path to an accumulating attribute in a rule context are
combined. For example, add the following specifications to the above
example:

     SYMBOL Program INHERITS AddOn COMPUTE
       SYNT. AnalysisDone += AllWaysDo ( );
     END;
     CLASS SYMBOL AddOn COMPUTE
       SYNT. AnalysisDone += AndAlsoDo ();
     END;
Then all four computations for `Program.AnalysisDone' (two in the RULE
context above, one in the TREE symbol context `Program', and one
inherited from the `CLASS' symbol `AddOn') will be combined into one.
It characterizes the state after execution of the four function calls
and the computation of `Statements.checked'.

Restrictions
............

If an attribute has an accumulating computation, it is called an
accumulating attribute, and may not have or inherit non-accumulating
computations.

An accumulating attribute must have type `VOID'.

Let `X' be the left-hand side nonterminal in a rule `r' and `X.s' an
accumulating synthesized attribute, then there must be at least one
accumulating computation for `X.s' in `r' or inherited there.

Let `X[i]' be an occurrence of the nonterminal `X' on the right-hand
side of the rule `r' and `X.s' an accumulating inherited attribute,
then there must be at least one accumulating computation for `X[i].s'
in `r' or inherited there.

`CHAIN' computations and `CHAIN' attributes may not be accumulating.


File: lidoref,  Node: Attributes,  Next: Expressions,  Prev: Computations,  Up: top

Attributes
**********

Attributes are associated with symbols and with rules.  They are
defined and used in rule computations and in symbol computations.

Each symbol has two disjoint sets of attributes: "synthesized" (`SYNT')
attributes that are defined by computations in lower contexts of the
symbol, and "inherited" (`INH') attributes that are defined by
computations in upper contexts of the symbol.

Attributes are introduced by their occurrence in computations.  They
are not explicitly declared. How types and classes of attributes are
determined is described in *Note Types and Classes of Attributes::.

Types and classes of attributes are described in

* Menu:

* Types and Classes of Attributes::

Syntax
......

         Attribute ::= SymbolRef '.' AttrName
                     | RuleAttr
         RuleAttr  ::= '.' AttrName
         SymbolRef ::= SymbName
                     | SymbName '[' Number ']'
         RhsAttrs  ::= 'RHS' '.' AttrName

Examples
........

         RULE: Stmt ::= 'while' Expr 'do' Stmt COMPUTE ...
           ... Expr.postType ...
           ... Stmt[1].code ...
           ... .label ...
           ... RuleFct ("PTG", RHS.Ptg) ...
         END;
         SYMBOL Expr COMPUTE
           ... SYNT.preType ...
           ... INH.postType ...
           ... THIS.preType ...
           ... RuleFct ("PTG", RHS.Ptg) ...
         END;

Attributes in rule computations have the form `X.a' or `X[i].a' where
`X' is a nonterminal in the production of the rule. They refer to the
attribute `a' of the tree node corresponding to `X'. The index
distinguishes multiple occurrences of the nonterminal in the
production, counting from left to right starting at 1.

"Rule attributes" of the form `.b' may be used in rule computations,
to simplify reuse of computed values. They are defined and used within
the computations of a single rule. They are not associated with any
symbol.

In symbol computations attributes of the considered symbol are denoted
using `SYNT', `INH', or `THIS' instead of the `SymbName': `SYNT.a' for
a synthesized attribute, `INH.b' for an inherited attribute, or
`THIS.c' leaving the attribute class to be specified elsewhere.

A `RhsAttrs' construct, such as `RHS.a', is a shorthand for a sequence
of attributes all named `a', one for each right-hand side nonterminal
of the rule context associated with the computation. If there is more
than one such nonterminal the construct may only occur in function
calls, where it contributes part of the argument sequence, or in
`DependsClauses'(*note Dependent Expressions::.).  If a symbol
computation contains a `RhsAttrs' its sequence of attributes is
determined for each rule context of the symbol individually. In
combination with the predefined function `RuleFct' a `RhsAttrs'
construct may be used to specify a call pattern that is instantiated
differently for each rule context (*note Predefined Entities::.).

Restrictions
............

The `SymbolRef' must occur in the production of the rule.

The `SymbolRef' must be indexed if and only if the symbol occurs more
than once in the production.

The index of a `SymbolRef' must identify an occurrence of the symbol
in the production.

`SymbNames' and indices may not be used in attributes of symbol
computations.

Rule attributes may not be used in symbol computations.


File: lidoref,  Node: Types and Classes of Attributes,  Up: Attributes

Types and Classes of Attributes
===============================

Each attribute has a certain type characterizing the values propagated
by the attribute.  Attributes that describe only postconditions of
computations without propagating a value have the predefined type
`VOID'.  Non-`VOID' types must be specified explicitly.

Each attribute has either the class synthesized (`SYNT'), if it is
computed in all lower contexts of its symbol, or it has the class
inherited (`INH'), if it is computed in all upper contexts of its
symbol. Attribute classes are usually derived from computations
without explicit specifications.

Syntax
......

         AttrSpec     ::= 'ATTR' AttrNames ':' TypeName [ AttrClass ]
     
         SymSpec      ::= SymbKind SymbNames ':' [ AttrSpecs ]
     
         AttrSpecs    ::= AttrSpecs ',' AttrSpecs
                        | AttrNames ':' TypeName [ AttrClass ]
     
         AttrClass    ::= 'SYNT' | 'INH'

Examples
........

         ATTR code: PTGNode SYNT;
         SYMBOL Expr, UseIdent: preType, postType: DefTableKey;

An attribute name specification (`ATTR') determines the type and
optionally the class of all attributes having one of the `AttrNames'.

An `AttrSpec' for a nonterminal determines the type and optionally the
class of attributes given by the `AttrNames' for all nonterminals
given by `SymbNames'. These specifications override the type and the
attribute class stated by `ATTR' specifications.

If the type of an attribute is left unspecified it is assumed to be
`VOID'.

Note: Misspelling of an attribute name in a computation leads to
introduction of a `VOID' attribute, and is usually indicated by
messages on missing computations for that attribute or illegal use of
a `VOID' attribute.

Note: The type of a non-`VOID' rule attribute has to be specified by
`ATTR' specifications.

Restrictions
............

There may be several `ATTR'specifications for the same `AttrName'
provided their properties are not contradictory.

A specified attribute class must be consistent with all computations
of that attribute.

`VOID' attributes may not be used in value contexts.

The type specified for an attribute must denote an assignable C type
that is available in the generated evaluator.  LIGA does not check
whether non-`VOID' attributes are used consistently with respect to
their types.  Violations will be indicated when the generated
evaluator is compiled.


File: lidoref,  Node: Expressions,  Next: Inheritance of Computations,  Prev: Attributes,  Up: top

Expressions
***********

An expression is evaluated as part of a computation. The evaluation may
yield a value, cause an effect, or both.

Different forms of expressions are described in

* Menu:

* Dependent Expressions::
* Terminal Access::
* Simple Expressions::


File: lidoref,  Node: Dependent Expressions,  Next: Terminal Access,  Up: Expressions

Dependent Expressions
=====================

The evaluation of an expression depends on all attributes to which it
refers.  The expression is evaluated only after all those attributes
are evaluated.

Further attributes may be added as preconditions for expression
evaluation without using their values for computing the expression's
result. The additional attributes may describe a computational state
that has to be reached before the expression is evaluated. These
attributes are specified by a `DependsClause'.

Syntax
......

         Expression    ::= SimpExpr [ DependsClause ]
         DependsClause ::= '<-' DepAttrList
         DepAttrList   ::= DepAttr
                         | '(' DepAttrs ')'
         DepAttrs      ::= DepAttrs ',' DepAttrs
                         | DepAttr
         DepAttr       ::= Attribute | RemoteAccess | RhsAttrs

Examples
........

         GetProp (UseId.Key,0) <- UseId.PropIsSet
         printf ("%s ", Opr.String) <- (Expr[2].printed, Expr.[3].printed)

A `DependsClause' has a `VOID' context, i.e. its attributes may have
any type; their values are discarded.


File: lidoref,  Node: Terminal Access,  Next: Simple Expressions,  Prev: Dependent Expressions,  Up: Expressions

Terminal Access
===============

Named terminal symbols that occur in a production represent values
that are usually obtained from corresponding input tokens when the
tree node is constructed. Those values can be used in both rule and
symbol computations.

Syntax
......

         SimpExpr ::= SymbolRef
                    | 'TERM' [ '[' Number ']' ]

Examples
........

         RULE:   DefIdent ::= Ident COMPUTE
           DefIdent.Key = DefineIdn (DefIdent.Env, Ident);
         END;
         RULE:   Point ::= '(' Numb Numb ')' COMPUTE
           printf ("X = %d, Y = %d\n", Numb[1], Numb[2]);
         END;
         SYMBOL Point COMPUTE
           printf ("X = %d, Y = %d\n", TERM[1], TERM[2]);
         END;

In rule computations the value of a terminal in the production is
denoted by the `SymbName', which is indexed if and only if there are
multiple occurrences of the `SymbName' in the production.

Note: In a rule computation a non-indexed identifier that is not a name
of a symbol in the production of this rule denotes some entity of the
generated C program, even if it coincides with the name of a terminal
that occurs in other productions.

In lower computations of a symbol `X' terminal values are accessed by
`TERM' or `TERM[i]', where `TERM' is equivalent to `TERM[1]'.
`TERM[i]' denotes the `i'-th terminal in each production that has `X'
(or a symbol that inherits `X') on its left-hand side, regardless of
the terminal's name.

Restrictions
............

`TERM' must not be used in rule computations or in upper symbol
computations.

A terminal accessed in a symbol computation must exist in every
production the computation is associated with.


File: lidoref,  Node: Simple Expressions,  Prev: Terminal Access,  Up: Expressions

Simple Expressions
==================

Expressions are written as nested function calls where the basic
operands are attributes, C identifiers and C literals.  The functions
are either predefined in LIDO or their definitions are supplied by the
user in the form of C functions or macros outside the LIDO
specification. There is no operator notation for expressions in LIDO.

Syntax
......

         SimpExpr  ::= C_Name | C_Integer | C_Float | C_Char | C_String
                     |  Attribute | RemoteAccess | RhsAttrs
                     |  FunctionName '(' [ Arguments ] ')'
         Arguments ::= Arguments ',' Arguments
                     |  Expression

Examples
........

         printf ("Val = %d\n", Expr.val)
         IF (LT (Expr.val, 0), 0, Expr.val)

Evaluation of a function call notation in LIDO has the same effect and
result as the equivalent notation in C.

There are some predefined `FunctionNames' that have a special meaning
in LIDO (*note Predefined Entities::.).

Function calls need not yield a value if they are in a `VOID' context. 
All arguments of a function call are in a value context.

`C_Name', `C_Integer', `C_Float', `C_Char', `C_String' are names and
literals denoted as in C.

Restrictions
............

Every `FunctionName' and `C_Name' must be predefined in LIDO or
supplied by a user definition.

All arguments of non-predefined functions must yield a (non-`VOID')
value. For predefined LIDO functions specific rules apply (*note
Predefined Entities::.).

Type consistency for non-`VOID' types is not checked by LIGA.  Those
checks are deferred to the compilation of the generated evaluator.

A `C_Name' or a `FunctionName' should not begin with an underscore, in
order to avoid conflicts with LIGA generated identifiers.


File: lidoref,  Node: Inheritance of Computations,  Next: Remote Attribute Access,  Prev: Expressions,  Up: top

Inheritance of Computations
***************************

A set of related computations can be associated with a `CLASS' symbol
describing a certain computational role. It can be inherited by `TREE'
symbols or by other `CLASS' symbols, thus specifying that they play
this role and reusing its computations.  A symbol can play several
roles at the same time (multiple inheritance).  Inherited computations
can be overridden by other computations of attributes having the same
name.  `CLASS' specifications have the same notation and meaning as
`SYMBOL' specifications.

Syntax
......

         Specification ::= SymbKind SymbName [ Inheritance ]
                            Computations 'END' ';'
         Inheritance   ::= 'INHERITS' SymbNames

Example:
           CLASS SYMBOL RootSetLine COMPUTE
             SYNT.GotLine = CONSTITUENTS KeySetLine.GotLine;
           END;
     
           CLASS SYMBOL KeySetLine COMPUTE
             SYNT.GotLine = ResetLine (THIS.Key,LINE);
           END;
     
           CLASS SYMBOL KeyPrintLine COMPUTE
             printf ("identifier in Line %d defined in line %d\n",
                     LINE, GetLine (THIS.Key,o))
                <- INCLUDING RootSetLine.GotLine;
           END;
     
           SYMBOL VarDefId  INHERITS KeySetLine   END;
           SYMBOL ProcDefID INHERITS KeySetLine   END;
           SYMBOL UseIdent  INHERITS KeyPrintLine END;
           SYMBOL Program   INHERITS RootSetLine  END;

`CLASS' computations obey the same rules as symbol computation.

The sets of lower and upper class computations may be accumulated from
several `CLASS' specifications for the same class.

`CLASS' computations may be inherited by `TREE' symbols or by other
`CLASS' symbols.

A `CLASS' or a `TREE' symbol `Target' inherits the computations from a
`CLASS' `Source' if there is a `Target INHERITS Source' relation
specified. The complete inheritance relation is accumulated by all
`INHERITS' specifications.

A computation is inherited only once even if there are several paths to
it in the inheritance relation.

A computation for an attribute `a' associated with a `CLASS' or a
`TREE' symbol overrides any computation for `a' inherited from a
`CLASS' symbol.

Note: Plain computations can not be overridden.

The computations inherited by a `CLASS' symbol belong to the
computation sets of the `CLASS' symbol and may be subject to further
inheritance.

Restrictions
............

`TREE' symbols and `CLASS' symbols may not inherit from `TREE' symbols.

The inheritance relation must not be cyclic.

If `C' inherits from `CLASS' symbols `C1' and `C2', and if both `C1'
and `C2' have computations for an attribute `a', it is undefined which
one is inherited by `C'.


File: lidoref,  Node: Remote Attribute Access,  Next: Computed Subtrees,  Prev: Inheritance of Computations,  Up: top

Remote Attribute Access
***********************

Remote access constructs are used to relate computations that belong
to distant contexts in the tree, rather than those of adjacent
contexts. The `INCLUDING' construct accesses attributes of symbols
that are further up in the tree (i. e. closer to the root). The
`CONSTITUENT(S)' construct accesses attributes of symbols that are
further down in the tree (i. e. closer to the leaves). The `CHAIN'
construct relates computations in a left-to-right depth-first order
within subtrees.

These constructs may propagate values or simply specify dependencies
between computations.

Remote access constructs are used to abstract from the particular tree
structure between related computations. Computational patterns can be
specified independent of the particular grammar using remote access in
combination with symbol computations and `CLASS' symbols. Reusable
specification modules are based on that technique.

The three forms of remote access constructs are described in

* Menu:

* INCLUDING::
* CONSTITUENT(S)::
* CHAIN::


File: lidoref,  Node: INCLUDING,  Next: CONSTITUENT(S),  Up: Remote Attribute Access

INCLUDING
=========

The `INCLUDING'-construct accesses an attribute of a symbol that is on
the path towards the tree root. Hence, several computations in a
subtree may depend on an attribute at the subtree root.

Syntax
......

         RemoteAccess ::= 'INCLUDING' RemAttrList
         RemAttrList  ::=  RemAttr | '(' RemAttrs ')'
         RemAttrs     ::=  RemAttr ',' RemAttrs '|' RemAttr
         RemAttr      ::=  SymbName '.' AttrName

Examples
........

         INCLUDING Range.Env
         INCLUDING (Block.Scope, Root.Env)

The `RemAttrList' specifies the set of attributes referred to by the
`INCLUDING' construct, called the "referred set". On evaluation it
accesses an attribute of the first symbol on the path to the root
which is in that set.

An `INCLUDING' in a rule computation accesses an attribute of a symbol
above the current context, even if the left-hand side symbol is in the
`RemAttrList'.

An `INCLUDING' in a symbol computation accesses an attribute of a
symbol above the current one, even if the current one is in the
`RemAttrList'.

An attribute of a `CLASS' symbol `C.a' in the `RemAttrList' contributes
attributes `X.a' to the referred set for all `TREE' symbols `X' by
which `C' is inherited.

An `INCLUDING' in a `VOID' context does not cause a value to be
propagated; it just states a dependency.

Restrictions
............

The referred set may not be empty, unless the computation which
contains it is not part of or inherited by any rule context.

The tree grammar must guarantee that in every tree there is at least
one of the symbols of the referred set above the context of the
`INCLUDING'.

The referred set must not contain different attributes of the same
symbol.

The types of the attributes in the referred set must be equal, unless
`INCLUDING' is in a `VOID' context.


File: lidoref,  Node: CONSTITUENT(S),  Next: CHAIN,  Prev: INCLUDING,  Up: Remote Attribute Access

CONSTITUENT(S)
==============

The `CONSTITUENTS'-construct accesses attributes of symbols that are in
the subtree of the current context. Hence, it may depend on several
computations in the subtree. If values are to be propagated they are
combined by user defined functions.

The `CONSTITUENT'-construct accesses a single attribute instance of a
symbol that is in the subtree of the current context.

Syntax
......

         RemoteAccess ::= [ SymbolRef ] 'CONSTITUENT'
                          RemAttrList [ ShieldClause ]
                        | [ SymbolRef ] 'CONSTITUENTS'
                          RemAttrList [ ShieldClause ] [ WithClause ]
         ShieldClause ::= 'SHIELD' SymbNameList
         SymbNameList ::= SymbName | '(' SymbNames ')' | '(' ')'
         WithClause   ::= 'WITH' '(' TypeName ',' CombFctName ','
                                     SingleFctName ',' NullFctName ')'

Examples
........

         CONSTITUENT Declarator.type
         Declarations CONSTITUENTS DefIdent.GotType
         CONSTITUENTS Range.GotLocKeys SHIELD Range
         CONSTITUENTS Stmt.code SHIELD Stmt
            WITH (PTGNode, PTGSeq, IDENTICAL, PTGNull)

The `RemAttrList' specifies the set of attributes referred to by the
`CONSTITUENT(S)' construct, called the "referred set".  On evaluation
it accesses all instances of attributes of that set which are in a
certain range of the subtree of the current context. That range is
determined by its root node, which itself does not belong to the
range, and by the set of shield symbols. The tree nodes below a shield
symbol are excluded from that range.

In a rule computation the root of the tree range is the node
corresponding to the left-hand side of the production. The optional
`SymbolRef' may restrict the root of the tree range to a node
corresponding to a symbol of the right-hand side of the production.

In a (lower or upper) symbol computation the root of the tree range is
the node corresponding to that symbol.

If the optional `ShieldClause' is given it specifies the set of
shielded symbols. If an empty `ShieldClause' is given, no symbols are
shielded from the tree range.  If the `ShieldClause' is omitted then
the root symbol of the tree range (as described above) is shielded
from the range.

An attribute of a `CLASS' symbol `C.a' in the `RemAttrList' contributes
attributes `X.a' to the referred set for all `TREE' symbols `X' to
which `C' is inherited.

A `CLASS' symbol `C' in the `ShieldClause' contributes symbols `X' to
the set of shielded symbols for all `TREE' symbols `X' to which `C' is
inherited.

A `CONSTITUENT(S)' in a `VOID' context simply states a dependency and
does not cause a value to be propagated.

For a `CONSTITUENTS' that is not in `VOID' context a `WithClause'
specifies how the values of the accessed attribute instances are
combined into one value.

The given `TypeName' specifies the type of the result and of
intermediate values.

The `CombFctName' specifies a function (or macro) that is applied to
two values of the given type and yields one value of that type.

The `SingleFctName' specifies a function (or macro) that is applied to
each accessed attribute instance and yields a value of the given type.

The `NullFctName' specifies a function (or macro) that has no argument
and yields an intermediate value. It is called for every node in the
tree range that could have referred attribute instances below it
according to the tree grammar, but for the particular tree it has
none. Hence, the result of this function should be neutral with
respect to the combine function.

It is guaranteed that the combine function is applied to intermediate
values according to a post-order projection of the accessed tree nodes. 
It is left open in which associative order that function combines
intermediate values.

The referred set of a `CONSTITUENTS' may be empty if no attributes of
the `RemAttrList' are reachable in the subtree or if `CLASS' symbols
in the `RemAttrList' are not inherited to any `TREE' symbol.  In that
case a `VOID' `CONSTITUENTS' is ignored, and a value `CONSTITUENTS'
results in a call of the `NullFctName'.

Restrictions
............

A `SymbolRef' must denote a right-hand side symbol of the production.
It must not be specified in symbol computations.

A `CONSTITUENTS' in a value context must have a `WithClause'.

For a `CONSTITUENT' the tree grammar must guarantee that the accessed
attribute instance is uniquely determined for every tree.

The `RemAttrs' must have the same type if the `CONSTITUENT(S)' is in
value context.

