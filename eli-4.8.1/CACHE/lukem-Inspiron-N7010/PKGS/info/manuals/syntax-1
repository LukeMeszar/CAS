This is Info file syntax, produced by Makeinfo-1.43 from the input
file /home/lukem/Dropbox/CAS/eli-4.8.1/Eli/pkg/parser/syntax.tnf.


File: syntax,  Node: Top,  Next: Phrases,  Prev: (DIR),  Up: (DIR)

Syntactic Analysis
******************

   The purpose of syntactic analysis is to determine the structure of
the input text.  This structure consists of a hierarchy of "phrases",
the smallest of which are the "basic symbols" and the largest of which
is the "sentence".  The structure can be described by a tree with one
node for each phrase.  Basic symbols are represented by values stored
at the nodes.  The root of the tree represents the sentence.

   This manual explains how to use a `.con' specification to describe
the set of all possible phrases that could appear in sentences of a
language.  It also discusses methods of resolving ambiguity in such
descriptions, and how to carry out arbitrary actions during the
recognition process itself.  The use of `.perr' specifications to
improve the error recovery of the generated parser is described as
well.

   Computations over the input can be written with attribute grammar
specifications that are based on an abstract syntax.  The abstract
syntax describes the structure of an abstract syntax tree, much the
way the concrete syntax describes the phrase structure of the input. 
Eli uses a tool, called "Maptool", that automatically generates the
abstract syntax tree based on an analysis of the concrete and abstract
syntaxes and user specifications given in files of type `.map'.  This
manual will describe the rules used by Maptool to determine a unique
correspondence between the concrete and abstract syntax and the
information users can provide in `.map' files to assist in the process.

   This manual will also discuss how Maptool makes it possible to only
partially specify the concrete and abstract syntaxes, as long as
together they specify a complete syntax.

   Although Maptool simplifies the task of relating the phrase
structure of a language to the abstract syntax on which a computation
is based, it is cometimes necessary to use a parser that was not
generated by Eli to analyze phrase structure.  In that case, the
relationship between phrase structure and abstract syntax must be
embedded in a hand-coded tree construction module.  The last section
of this manual explains how such a module is implemented, and
describes the way in which Eli supports that implementation and manages
its integration with the generated tree computations.

* Menu:

* Phrases::	        Context-Free Grammars and Parsing
* Mapping::	        The Relationship Between Phrases and Tree Nodes
* Conflicts::	        How to Resolve Parsing Conflicts
* Actions::	        Carrying Out Actions During Parsing
* Error Recovery::      Improving Error Recovery in the Generated Parser
* Foreign::             Using Foreign parser generators
* Grammars::	        Grammars for the Specification Files
* Index::


File: syntax,  Node: Phrases,  Next: Mapping,  Prev: Top,  Up: Top

Context-Free Grammars and Parsing
*********************************

   A "context-free grammar" is a formal system that describes a
language by specifying how any legal text can be derived from a
distinguished symbol called the "axiom", or "sentence symbol".  It
consists of a set of "productions", each of which states that a given
symbol can be replaced by a given sequence of symbols.  To derive a
legal text, the grammar is used as data for the following algorithm:

  1. Let `text' be a single occurrence of the axiom.

  2. If no production states that a symbol currently in `text' can be
     replaced by some sequence of symbols, then stop.

  3. Rewrite `text' by replacing one of its symbols with a sequence
     according to some production.

  4. Go to step (2).

When this algorithm terminates, `text' is a legal text in the language. 
The "phrase structure" of that text is the hierarchy of sequences used
in its derivation.

   Given a context-free grammar that satisfies certain conditions, Eli
can generate a "parsing routine" to determine the derivation (and
hence the phrase structure) of any legal text.  This routine will also
automatically detect and report any errors in the text, and repair
them to produce a correct phrase structure (which may not be that
intended by the person who wrote the erroneous text).

* Menu:

* Notation::	How to describe a context-free grammar
* Meaning::	Using structure to convey meaning


File: syntax,  Node: Notation,  Next: Meaning,  Up: Phrases

How to describe a context-free grammar
======================================

   Each production of a context-free grammar consists of a symbol to
be replaced and the sequence that replaces it.  This can be
represented in a type-`con' file by giving the symbol to be replaced,
followed by a colon, followed by the sequence that replaces it,
followed by a period:

     Assignment: Variable ':=' Expression.
     StatementList: .
     Statement:
        'if' Expression 'then' Statement
        'else' Statement.

The first production asserts that the symbol `Assignment' can be
replaced by the sequence consisting of the three symbols `Variable',
`':='', and `Expression'.  Any occurrence of the symbol
`StatementList' can be replaced by an empty sequence according to the
second production.  In the third production, you see that new lines
can be used as separators in the description of a production.  This
notation is often more commonly referred to as "Backus Naur Form", or
just "BNF".

* Menu:

* Nonterminals::	Representations of symbols to be replaced
* Terminals::		Representations of character strings
* EBNF::                Using extended BNF to describe more complex rules


File: syntax,  Node: Nonterminals,  Next: Terminals,  Up: Notation

Representations of symbols to be replaced
-----------------------------------------

   Symbols that are to be replaced are called "nonterminals", and are
always represented by "identifiers".  (An identifier is a sequence of
letters and digits, the first of which is a letter.) Every nonterminal
must appear before a colon in at least one production.  The axiom is a
nonterminal that appears before the colon in exactly one production,
and does not appear between the colon and the period in any production. 
There must be exactly one nonterminal satisfying the conditions for
the axiom.


File: syntax,  Node: Terminals,  Next: EBNF,  Prev: Nonterminals,  Up: Notation

Representations of character strings
------------------------------------

   Symbols that cannot be replaced are called "terminals", and may be
represented by either identifiers or "literals".  (A literal is a
sequence of characters bounded by apostrophes (`'').  An apostrophe
appearing within a literal is represented by two successive
apostrophes.) No terminal may appear before a colon in any production. 
Terminals represent character strings that are recognized by the
lexical analyzer (*note Specifications: (lex)Specifications.).


File: syntax,  Node: EBNF,  Prev: Terminals,  Up: Notation

Using extended BNF to describe more complex rules
-------------------------------------------------

   "Extended BNF" allows the use of certain operators on the right
hand side of a production.  These operators are designed to be
short-hands to simplify the grammar description.  Rules with extended
BNF operators can be translated into rules which use only the strict
BNF constructs described so far.  While the use of extended BNF
constructs is supported for the concrete syntax description in Eli,
only strict BNF constructs are allowed in the abstract syntax.  When
it comes time to deduce the correspondence between the concrete and
abstract syntax, Maptool operates on the abstract syntax and a version
of the concrete syntax in which all rules containing extended BNF
constructs have been translated into equivalent strict BNF rules.

   The remainder of this section is devoted to describing how each of
the extended BNF constructs are translated to their strict BNF
equivalents.  Note that most of the EBNF constructs require the
introduction of generated symbols for their strict BNF translation. 
Users are strongly discouraged from using these constructs in
instances where attribution is required for those contexts, because
changes in the grammar will change the names of the generated symbols
used.

   The most appropriate use of EBNF constructs that introduce generated
symbols is when matching the LIDO `LISTOF' construct, since the
`LISTOF' construct makes no assumptions about the phrase structure of
the list.  For a description of the `LISTOF' construct, see *Note
Productions: (lidoref)Productions.

* Menu:

* Slash::	        Collecting replacements for the same symbol
* Square Brackets::	Optional symbols
* Asterisk::	        Zero or more occurrences
* Plus::	        One or more occurrences
* Double Slash::	Separator construct
* Parentheses::	        Symbol grouping


File: syntax,  Node: Slash,  Next: Square Brackets,  Up: EBNF

Collecting replacements for the same symbol
...........................................

   When a grammar contains many productions specifying replacement of
the same nonterminal, a slash, denoting "alternation" can be used to
avoid re-writing the symbol being replaced:

     Statement:
        Variable ':=' Expression /
        'if' Expression 'then' Statement 'else' Statement /
        'while' Expression 'do' Statement .

   This alternation specifies three productions.  The nonterminal to
be replaced is `Statement' in each case.  Possible replacement
sequences are separated by slashes (`/').  The strict BNF translation
for the above example is:

     Statement: Variable ':=' Expression .
     Statement: 'if' Expression 'then' Statement 'else' Statement .
     Statement: 'while' Expression 'do' Statement .

   Alternation does not introduce any generated symbols and has a very
straight-forward translation.  As a result, it is the most heavily used
of the EBNF constructs.


File: syntax,  Node: Square Brackets,  Next: Asterisk,  Prev: Slash,  Up: EBNF

Describing optional symbols within a rule
.........................................

   Square brackets are used to denote that the set of symbols enclosed
by the brackets are optional.  In the following example, `Constants'
and `Variables' are optional, but `Body' is not:

     Program: [Constants] [Variables] Body .

   The strict BNF translation of this construct is to generate a rule
for each possible permutation of the right hand side.  In the case of
the above example, the following four rules would result:

     Program: Body .
     Program: Variables Body .
     Program: Constants Body .
     Program: Constants Variables Body .

   While the translation doesn't introduce any generated symbols,
indiscriminate use of this construct may lead to less readable
specifications.


File: syntax,  Node: Asterisk,  Next: Plus,  Prev: Square Brackets,  Up: EBNF

Specifying zero or more occurrences
...................................

   An asterisk (or star) is used to denote zero or more occurrences of
the phrase to which it is applied.  In the following example,
`Program' consists of zero or more occurrences of `Variable' followed
by `Body':

     Program: Variable* Body .

   The strict BNF translation of this construct requires the
introduction of a generated symbol.  Generated symbols begin with the
letter `G' and are followed by a unique number.  Generated symbols are
chosen to not conflict with existing symbols in the concrete syntax. 
No check is performed to ensure that the generated symbols do not
conflict with symbols in the abstract syntax, so users should avoid
using symbols of this form in their abstract syntax.  The translation
for the above example is as follows:

     Program: G1 Body .
     G1: G1 Variable .
     G1: .


File: syntax,  Node: Plus,  Next: Double Slash,  Prev: Asterisk,  Up: EBNF

Specifying one or more occurrences
..................................

   A plus is used to denote one or more occurrences of the phrase to
which it is applied.  In the following example, `Program' consists of
one or more occurrences of `Variable' followed by `Body':

     Program: Variable+ Body .

   The strict BNF translation of this construct is similar to the
translation of the asterisk (*note Asterisk::.).  The translation for
the above example is as follows:

     Program: G1 Body .
     G1: G1 Variable .
     G1: Variable .


File: syntax,  Node: Double Slash,  Next: Parentheses,  Prev: Plus,  Up: EBNF

EBNF Separator construct
........................

   A double slash is used to denote one or more occurrences of a phrase
separated by a symbol.  In the following example, `Input' is a
sequence of one or more `Declaration''s separated by a comma:

     Input: Declaration // ',' .

   The strict BNF translation for the above example is as follows:

     Input: G1 .
     G1: G2 .
     G1: G1 ',' G2 .
     G2: Declaration .

   Note that all of the EBNF constructs, except the single slash (for
alternation) have higher precedence than the separator construct.


File: syntax,  Node: Parentheses,  Prev: Double Slash,  Up: EBNF

Grouping constructs in EBNF expressions
.......................................

   Parentheses are used to group EBNF constructs.  This is used
primarily to apply other EBNF operators to more than a single symbol. 
For example:

     Program: (Definition Use)+ .

   In this example, we want to apply the Plus operator to the
concatenation of a `Definition' and a `Use'.  The result denotes one
or more occurrences of `Definition''s followed by `Use''s.  The strict
BNF translation for the above is:

     Program: G2 .
     G1: Definition Use .
     G2: G1 .
     G2: G2 G1 .

   This is identical to the translation for the Plus operator
operating on a single symbol, except that another generated symbol is
created to represent the parenthetical phrase.

   Note that a common error is to introduce parentheses where they are
not needed.  This will result in the introduction of unexpected
generated symbols.


File: syntax,  Node: Meaning,  Prev: Notation,  Up: Phrases

Using structure to convey meaning
=================================

   A production is a construct with two components: the symbol to be
replaced and the sequence that replaces it.  We defined the meaning of
the production in terms of those components, saying that whenever the
symbol was found in `text', it could be replaced by the sequence. 
This is the general approach that we use in defining the meaning of
constructs in any language.  For example, we say that an assignment is
a statement with two components, a variable and an expression.  The
meaning of the assignment is to replace the value of the variable with
the value resulting from evaluating the expression.

   The context-free grammar for a language specifies a "component"
relationship.  Each production says that the components of the phrase
represented by the symbol to be replaced are the elements of the
sequence that replaces it.  To be useful, the context-free grammar for
a language should embody exactly the relationship that we use in
defining the meanings of the constructs of that language.

* Menu:

* Precedence::	Operator precedence
* Association::	Operator associativity
* Scope::	Scope rules for declarations


File: syntax,  Node: Precedence,  Next: Association,  Up: Meaning

Operator precedence
-------------------

   Consider the following expressions:

     A + B * C
     (A + B) * C

In the first expression, the operands of the addition are the variable
`A' and the product of the variables `B' and `C'.  The reason is that
in normal mathematical notation, multiplication takes precedence over
addition.  Parentheses have been used in the second expression to
indicate that the operands of the multiplication are the sum of
variables `A' and `B', and the variable `C'.

   The general method for embodying this concept of operator
precedence in a context-free grammar for expressions is to associate a
distinct nonterminal with each precedence level, and one with operands
that do not contain "visible" operators.  For our expressions, this
requires three nonterminals:

`Sum'
     An expression whose operator is `+'

`Term'
     An expression whose operator is `*'

`Primary'
     An expression not containing "visible" operators

   The productions that embody the concept of operator precedence
would then be:

     Sum: Sum '+' Term / Term.
     Term: Term '*' Primary / Primary.
     Primary: '(' Sum ')' / Identifier.


File: syntax,  Node: Association,  Next: Scope,  Prev: Precedence,  Up: Meaning

Operator associativity
----------------------

   Consider the following expressions:

     A - B - C
     A ** B ** C
     A < B < C

Which operator has variable `B' as an operand in each case?

   This question can be answered by stating an "association" for each
operator: If `-' is "left-associative", then the first expression is
interpreted as though it had been written `(A-B)-C'.  Saying that `**'
is "right-associative" means that the second expression is interpreted
as though it had been written `A**(B**C)'.  The language designer may
wish to disallow the third expression by saying that `<' is
"non-associative".

   Association rules are embodied in a context-free grammar by
selecting appropriate nonterminals to describe the operands of an
operator.  For each operator, two nonterminals must be known: the
nonterminal describing expressions that may contain that operator, and
the nonterminal describing expressions that do not contain that
operator but may be operands of that operator.  Usually these
nonterminals have been established to describe operator precedence. 
Here is a typical set of nonterminals used to describe expressions:

`Relation'
     An expression whose operator is `<' or `>'

`Sum'
     An expression whose operator is `+' or `-'

`Term'
     An expression whose operator is `*' or `/'

`Factor'
     An expression whose operator is `**'

`Primary'
     An expression not containing "visible" operators

   The association rules discussed above would therefore be expressed
by the following productions (these are *not* the only productions in
the grammar):

     Sum: Sum '-' Term.
     Factor: Primary '**' Factor.
     Relation: Sum '<' Sum.

The first production says that the left operand of `-' can contain
other `-' operators, while the right operand cannot (unless the
subexpression containing them is surrounded by parentheses). 
Similarly, the right operand of `**' can contain other `**' operators
but the left operand cannot.  The third rule says that neither operand
 of `<' can contain other `<' operators.


File: syntax,  Node: Scope,  Prev: Association,  Up: Meaning

Scope rules for declarations
----------------------------

   Identifiers are normally given meaning by declarations.  The
meaning given to an identifier by a particular declaration holds over
some portion of the program, called the "scope" of that declaration. 
A context-free grammar for a language should define a phrase structure
that is consistent with the scope rules of that language.

   For example, the declaration of a procedure `P' within the body of
procedure `Q' gives meaning to the identifier `P', and its scope might
be the body of the procedure `Q'.  If `P' has parameters, the scope of
their declarations (which are components of the procedure declaration)
is the body of procedure `P'.

   Now consider the following productions describing a procedure
declaration:

     procedure_declaration: 'procedure' procedure_heading procedure_body.
     procedure_heading:
        ProcIdDef formal_parameter_part ';' specification_part.

Notice that the phrase structure induced by these productions is
inconsistent with the postulated scope rules.  The declaration of `P'
(`ProcIdDef') is in the same phrase (`procedure_heading') as the
declarations of the formal parameters.  This defect can be remedied by
a slight change in the productions:

     procedure_declaration: 'procedure' ProcIdDef ProcRange.
     ProcRange:
        formal_parameter_part ';' specification_part procedure_body.

Here the formal parameters and the body have both been made components
of a single phrase (`ProcRange'), which defines the scope of the formal
parameter declarations.  The declaration of `P' lies outside of this
phrase, thus allowing its scope to be differentiated from that of the
formal parameters.


File: syntax,  Node: Mapping,  Next: Conflicts,  Prev: Phrases,  Up: Top

The Relationship Between Phrases and Tree Nodes
***********************************************

   `RULE' declarations in files of type `lido' describe the structure
of the abstract syntax tree over which computations are performed. 
Eli will create a routine to construct an abstract syntax tree if any
tree computations are specified (*note Tree Structure:
(comptrees)Tree.).  In order to do this, Eli must be able to deduce a
unique correspondence between the concrete and abstract syntaxes, such
that for each rule in the concrete syntax it is possible to uniquely
determine what abstract syntax tree fragment to build.  The tool
within Eli that does this is called Maptool.  In addition to
generating a routine to construct the abstract syntax tree, Maptool
will also deduce complete versions of the concrete and abstract
syntaxes if only incomplete versions of each are provided by the user.
 This can only be done if the two syntaxes can together form a
complete syntax.

   The concrete syntax is provided by the user in files of type `con'. 
Since EBNF constructs are allowed in these files, they are first
translated into their strict BNF equivalents before being processed by
Maptool (*note EBNF::.).  The abstract syntax is extracted from the
`RULE' declarations made in files of type `lido' (*note Rule
Specifications: (lidoref)Rule Specifications.).

   The remainder of this section will discuss how Maptool deduces the
correspondence between the two syntaxes, the use of files of type `map'
to influence the mapping process, and some usage hints.

* Menu:

* Process::     Mapping syntaxes and generating complete versions
* Map Files::   Specifications to influence the mapping process
* BOTTOMUP::    Influences of BOTTOMUP specifications on mapping
* Hints::       Hints for syntax development


File: syntax,  Node: Process,  Next: Map Files,  Up: Mapping

Syntax mapping process
======================

   Maptool begins by matching any `LISTOF' constructs that appear in
the abstract syntax to any appropriate concrete rules.  The next phase
examines each concrete rule not matched in the previous phase and
tries to find a matching abstract syntax rule.  After all matching is
complete, unmatched concrete rules are added to the abstract syntax
and unmatched abstract rules are added to the concrete syntax.  There
are a few exceptions to this as are noted in the remainder of this
section.

   While the most obvious benefit to having Maptool deduce syntax
fragments from one syntax and place them in the other is to reduce the
amount of typing required, the more important advantage is the support
it gives for incremental development.  It allows the user to only
specify those portions of the syntax with which they are concerned at
the moment.

* Menu:

* Chain Rules::         Definitions for different kinds of chain rules
* LISTOF::              Matching abstract `LISTOF' constructs
* Rule Matching::       Matching the remaining rules
* Completion::          Generation of the complete syntaxes


File: syntax,  Node: Chain Rules,  Next: LISTOF,  Up: Process

Chain rule definitions
----------------------

   Chain rules have different behavior than other rules during the
matching process. Descriptions for three different kinds of chain
rules are given here to assist in the explanations given in the
remainder of this section:

"Chain Rule"
     A normal chain rule is a rule in which there is exactly one
     symbol on the right hand side of the rule that is not equivalent
     to the left hand side.  For example, `X ::= Y' where X is not
     equivalent to Y is a chain rule.

"Trivial Chain Rule"
     A trivial chain rule is a chain rule in which the left hand side
     is equivalent to the right hand side.  This typically happens
     when a symbolic equivalence class is defined that includes both
     the left hand side symbol and the right hand side symbol (*note
     Symbol Mapping::.).

"Literal Chain Rule"
     A literal chain rule is similar to a trivial chain rule, except
     that it also has literal symbols on its right hand side.  A
     typical example of this is the rule `Expr ::= '(' Expr ')''.

   Based on the above definition for normal chain rules, we define
"coercions" between symbols.  A symbol `X' can be coerced to a symbol
`Y' if there is a chain rule with `X' on the right hand side and `Y' on
the left hand side.  Coercions are also transitive.  If `X' is
coercible to `Y' and `Y' is coercible to `Z', then `X' is also
coercible to `Z'.  A symbol is also considered coercible to itself.


File: syntax,  Node: LISTOF,  Next: Rule Matching,  Prev: Chain Rules,  Up: Process

Matching the `LISTOF' construct
-------------------------------

   The `LISTOF' construct denotes zero or more occurrences of the
elements that appear on its right hand side.  It does not dictate the
ordering of those right hand side symbols or any delimiters that may
be used to separate them.  The ordering and delimiters are determined
by concrete rules.  In simple terms, Maptool begins with the left hand
side of the `LISTOF' and recursively matches rules until it finds the
right hand side elements.  The next paragraph gives a more precise
description.

   An abstract `LISTOF' construct is matched by starting with the
symbol on the left hand side of the LISTOF.  All concrete rules with
equivalent left hand side symbols are added to the set of matched
rules.  For each rule added to the set, the right hand side symbols
are examined.  Of these symbols, literal symbols are ignored.  If
terminal symbols are encountered that aren't coercible to the symbols
appearing on the right hand side of the `LISTOF', an error is
signalled, because the left hand side of the `LISTOF' may not derive
symbols other than those that appear on the right hand side.  For each
nonterminal symbol that isn't coercible to one of the right hand side
symbols, the concrete rules that have that symbol on their left hand
side are added to the set.  The process continues until no more rules
can be added to the set.

   The intermediate nonterminal symbols that are encountered as new
concrete rules are added to the set may not appear on the right hand
side of other concrete rules.

   If Maptool doesn't find any concrete rules to match a `LISTOF', it
will generate a canonical left recursive representation.  For the list:

     RULE: Program LISTOF Declaration | Statement END;

   Maptool would generate the following:

     Program: LST_Program .
     LST_Program: LST_Program Declaration .
     LST_Program: LST_Program Statement .
     LST_Program: .

   This specifies zero or more occurrences of `Declaration''s and
`Statement''s.

   There is one other important thing to note about the `LISTOF'
construct.  Attribute computations associated with a `LISTOF'
construct can just as easily be written as symbol computations on the
symbols of the `LISTOF'.  The advantage to using the `LISTOF'
construct is that it becomes possible to generate an abstract syntax
tree structure which allows for more efficient traversal.  In order to
construct this special tree structure, it is sometimes necessary to
insert an additional chain rule into the concrete syntax at the root
of the `LISTOF'.

   This is the case when the rules matching the `LISTOF' have a
recursive occurrence of the left hand side symbol.  As an example, the
`LISTOF' construct shown above might be written as follows in the
concrete syntax:

     Program: Program Declaration .
     Program: Program Statement .
     Program: .

   As you can see, the root of the `LISTOF', `Program' is used both on
the left hand side and right hand side of rules that match the `LISTOF'
construct, meaning that it is used recursively.  If the `LISTOF'
construct is provided in a `.lido' file, Maptool must introduce the
chain rule `Program ::= LST_Program' and change other occurrences of
`Program' to `LST_Program' in order to build the efficient tree
structure.

   Users should be aware that it is possible for the addition of this
chain rule to cause LALR(1) conflicts for the parsability of the
concrete syntax that do not appear in the absence of the `LISTOF'
construct.  In these cases, users must either rewrite the concrete
syntax or avoid the use of the `LISTOF' construct to avoid the problem.


File: syntax,  Node: Rule Matching,  Next: Completion,  Prev: LISTOF,  Up: Process

Matching remaining rules
------------------------

   After all `LISTOF' constructs have been matched, Maptool attempts
to match the remaining concrete rules to rules given in the abstract
syntax.  A match is determined if the signature of the concrete rule
is equivalent to the signature of an abstract rule or coercions (*note
Chain Rules::.) exist between any symbols which differ in the
signatures.  Remember that symbolic equivalence classes are applied to
concrete rules before this matching takes place, so symbols in the
signatures are considered equivalent if they belong to the same
equivalence class.

   For example, consider the following abstract rules:

     RULE: Declaration ::= IdDef Type END;
     RULE: IdDef ::= Identifier END;

   The following concrete rule will match the first of the above
abstract rules, because of the coercion defined between `Identifier'
and `IdDef':

     Declaration: Identifier Type .

   The reason for doing this is to distinguish semantically between
occurrences of `Identifier''s in different contexts.  In the above
example, we have used `IdDef' to represent a definition of an
`Identifier'.  In another place in the grammar, we may want to refer
to uses of identifiers instead and use the symbol `IdUse'.  Note that
use of chain rules in the manner just described makes it impossible to
perform attribute computations during tree construction (*note
Constraints::.).

   It is possible for Maptool to detect multiple possible matching
abstract rules for a single concrete rule.  Maptool signals an error
in this case that must be fixed by changing the grammar to
disambiguate the contexts.


File: syntax,  Node: Completion,  Prev: Rule Matching,  Up: Process

Complete generated concrete and abstract syntaxes
-------------------------------------------------

   After rule matching is complete, unmatched concrete rules, except
trivial chain rules and literal chain rules (*note Chain Rules::.) are
added to the abstract syntax.  The reason for this is that trivial
chain rules are meaningless in the abstract syntax and literal chain
rules are only meaningful if they have attribute computations
associated with them, in which case they would already have been
specified as part of the abstract syntax.

   Sometimes it is desirable to include literal chain rules in the
abstract syntax even when the user has not explicitly included them
there.  A typical situation where this occurs is when generating
output conforming to the concrete syntax using the Idem tool (*note
Textual unparser: (idem)idem.).  In this situation the output must
contain all literals hence the literal chain rules must be in the
abstract syntax so that Idem can generate output patterns for them. 
To preserve the literal chain rules in the abstract syntax use the
`MAPCHAINS' keyword in a specification (*note Mapping Chain Rules::.).

   Unmatched abstract rules are included in the concrete syntax except
in the following instances:

   * The rule is a chain rule whose left hand side is not a symbol in
     the concrete syntax.  Adding the rule to the concrete syntax in
     this case would cause the concrete syntax to be disconnected.

   * The rule can only be part of a computed subtree (*note Computed
     Subtrees: (lidoref)Computed Subtrees.).  This is true if the rule
     is only reachable from the root symbol if symbols preceded by a
     `$' are included.

   Users can use the `:consyntax' product (*note consyntax:
(pp)consyntax.) to view the complete version of the concrete syntax.

   The `:abstree' product (*note abstree: (pp)abstree.) is used to view
the complete abstract tree grammar.  The `:absyntax' product (*note
absyntax: (pp)absyntax.) by contrast only shows the abstract syntax
rules which are not part of computed subtrees.


File: syntax,  Node: Map Files,  Next: BOTTOMUP,  Prev: Process,  Up: Mapping

User mapping specifications
===========================

   Files of type `map' can be provided by the user to influence the
way in which certain rules are matched.  The syntax of map files can
be found with other grammar description towards the end of this
document (*note Grammars::.).

   There are currently three ways in which the mapping can be affected. 
The first are symbolic equivalence classes, which group together
symbols that have the same semantic meaning.  The second method is to
map specific rules.  Using this method, concrete rules can be rewritten
and/or reordered to match a specific abstract rule.  The third method
controls the elimination of literal chain rules.

* Menu:

* Symbol Mapping::        Specifying symbolic equivalence classes
* Rule Mapping::          Rewriting a concrete rule
* Mapping Chain Rules::   Preserving literal chain rules


File: syntax,  Node: Symbol Mapping,  Next: Rule Mapping,  Up: Map Files

Specifying symbolic equivalence classes
---------------------------------------

   Symbolic equivalence classes are used to group together symbols
appearing in the concrete syntax because the semantics of the symbols
are equivalent.  As a result, a single symbol can be used to represent
all of the members of the symbolic equivalence class in the abstract
syntax.  This representative symbol can either be one of the concrete
symbols or a new symbol altogether.  Symbolic equivalence classes are
specified in files of type `map'.  A series of symbolic equivalences
must be preceded by the keyword `MAPSYM'.  An equivalence class is
then specified by giving the representative symbol (the symbol to
appear in the abstract syntax), followed by `::=' and the list of
symbolically equivalent symbols from the concrete syntax terminated by
a period.  For example, the following specification says that a
`Primary', `Factor', and `Expr' belong to the same equivalence class:

     MAPSYM
     Expr ::= Primary Factor .

   Application of symbolic equivalence classes to rules in the
concrete syntax is done before the matching process begins.  Symbolic
equivalence classes can only be created for symbols which are either
all nonterminals or all terminals (*note Notation::.).  An error
message will also be issued if a symbolic equivalence class
specification includes abstract syntax symbols on the right hand side,
since each abstract syntax symbol represents its own equivalence class.

   For backward compatibility with previous releases of Eli, symbolic
equivalence classes may also be specified in files of type `sym'.


File: syntax,  Node: Rule Mapping,  Next: Mapping Chain Rules,  Prev: Symbol Mapping,  Up: Map Files

Specifying rule mappings
------------------------

   Rule mapping allows users to rewrite a concrete rule for the
purposes of matching it to a specific abstract rule.  This is useful
in cases where two syntactically different constructs are semantically
equivalent.  Consider the following expression language with bound
identifiers:

     Computation: LetExpr / WhereExpr .
     LetExpr: 'let' Definitions 'in' Expr .
     WhereExpr: Expr 'where' Definitions .

   In this example, `LetExpr' and `WhereExpr' are semantically
equivalent constructs, but the ordering of `Definitions' and `Expr'
are reversed and they use different literal symbols.  We'd like to
only specify the semantic computations for the two constructs once. 
To do this, we can define a symbolic equivalence class for `LetExpr'
and `WhereExpr':

     MAPSYM
     BoundExpr ::= LetExpr WhereExpr .

   The abstract rule that we can use to represent the two constructs
is:

     RULE: BoundExpr ::= Definitions Expr END;

   Finally, we must use rule mapping specifications to rewrite the two
concrete rules to match the abstract rule:

     MAPRULE
     LetExpr: 'let' Definitions 'in' Expr < $1 $2 > .
     WhereExpr: Expr 'where' Definitions < $2 $1 > .

   The keyword `MAPRULE' precedes a group of rule mapping
specifications in the map file.  Each rule mapping begins with the
concrete rule to be rewritten followed by its rewritten form in angle
brackets.  In angle brackets, nonliteral symbols appear as positional
parameters.  A positional parameter is specified with a `$' followed
by a number indicating which nonliteral symbol from the concrete rule
is to be used.  Any literal symbols may also appear between the angle
brackets.

   An abstract syntax will sometimes have several rules with different
names but identical signatures.  For example, consider the case where
dyadic expressions are represented by abstract rules that do not
contain operators:

     RULE Add: Expression ::= Expression Expression END;
     RULE Mul: Expression ::= Expression Expression END;
     ...

In this case, the rule mapping must specify the abstract rule name
explicitly in order to disambiguate the pattern match:

     MAPRULE
     Expression: '(' Expression '+' Expression ')' < $1 $2 >: Add .
     Expression: '(' Expression '*' Expression ')' < $1 $2 >: Mul .
     ...

Rule names are optional, and may be omitted when the pattern match is
unambiguous (as in the bound variable example).

   When rule matching proceeds, the concrete rule is seen in its
rewritten form.  An abstract syntax rule must exist in a LIDO
specification that corresponds to the rule mapping specification given. 
Note that the use of rule mapping makes it impossible to perform
attribute computations during tree construction (*note Constraints::.).


File: syntax,  Node: Mapping Chain Rules,  Prev: Rule Mapping,  Up: Map Files

Preserving literal chain rules
------------------------------

   The mapping process normally does not include literal chain rules
in the complete abstract syntax unless they appear in the user-supplied
abstract syntax (*note Completion::.).  Sometimes it is desirable to
preserve literal chain rules even if the user has not included them in
the abstract syntax.  To force literal chain rules to be included in
the abstract syntax, use the `MAPCHAINS' keyword.  The behavior is
unchanged if all literal chain rules already appear in the abstract
syntax.

   Care should be taken when using `MAPCHAINS' in conjunction with
attribution.  A specification using this keyword may require more
attribution than the same specification without it, because it may be
necessary to transfer attribute values from the child to the parent or
vice versa.  The presence of symbol computations for the symbols
occurring in the chain rules without the transfer computations just
mentioned may result in incorrect attribution without warning.


File: syntax,  Node: BOTTOMUP,  Next: Hints,  Prev: Map Files,  Up: Mapping

Influences of BOTTOMUP specifications on mapping
================================================

   The generation of the parsing grammar (the input to the parser) may
be influenced by `BOTTOMUP' specifications (*note Computations:
(lidoref)Computations.) specified in your attribute grammar.  This is
because the parsing grammar must ensure that the nodes of the abstract
syntax tree are constructed in a particular order in the presence of
`BOTTOMUP' constraints.

   In order to deal with this, Maptool must sometimes inject generated
chain rules into the parsing grammar to which tree building actions can
be attached.  These injected chain rules may cause the parsing grammar
to exhibit LALR(1) conflicts.  If so, an error will be reported to
indicate that the `BOTTOMUP' constraints you have provided cause your
grammar to not be parsable.

   In trying to resolve such a conflict, it is useful to use the
`:pgram' derivation (*note pgram: (pp)pgram.) to be able to view the
parsing grammar that is submitted to the parser generator and contains
the injected chain rules.  It is also useful to use the `:OrdInfo'
derivation to get more information about how `BOTTOMUP' constraints
were introduced for specific rules.  Approaches to resolving such a
problem include eliminating unnecessary `BOTTOMUP' constraints from
the attribute grammar or making changes to the concrete syntax that
allow the chain rules to be injected without causing LALR(1) conflicts.


File: syntax,  Node: Hints,  Prev: BOTTOMUP,  Up: Mapping

Syntax development hints
========================

   This section begins by describing typical patterns of syntax
development.  This is followed by two more specific examples of how to
use the mapping techniques described in the previous sections.

* Menu:

* Patterns::    Typical patterns of syntax development
* Constraints:: Constraints on grammar mapping
* Abstraction::	Abstracting information from literals
* Expression::	Mapping expressions for overload resolution


File: syntax,  Node: Patterns,  Next: Constraints,  Up: Hints

Typical patterns of syntax development
--------------------------------------

   When developing a translator for an existing language, the complete
concrete syntax is typically already available.  In these cases, it is
advantageous to start with the complete concrete syntax and add
symbolic equivalences and rule mapping specifications to suit the
attribute computations as they are being developed.

   On the other hand, when designing a new language, it is easier to
start work by specifying attribute computations and adding concrete
syntax rules as necessary to resolve issues of precedence,
associativity, and other parsing ambiguities.

   When errors relating to the syntax appear, it is strongly
recommended that the first course of action be to look at the complete
generated versions of the syntaxes by using the `:consyntax',
`:absyntax', and `:abstree' products (*note Specifications:
(pp)Specifications.).  Very often these problems are simply a result
of not correctly anticipating the matching process.


File: syntax,  Node: Constraints,  Next: Abstraction,  Prev: Patterns,  Up: Hints

Constraints on grammar mapping
------------------------------

   The LIGA attribute grammar system allows users to specify that the
first pass of computations are to be performed as the abstract syntax
tree is being built.  This is specified either by an option given in a
LIGA control specification *note Order Options: (lcl)Order Options. or
by using an additional keyword in an attribute grammar computation
*note Computations: (lidoref)Computations..

   Combining computations with tree construction, however, requires
that the tree be constructed in strict left-to-right and bottom-to-top
order.  In the presence of more advanced grammar mappings, it is not
possible to maintain this strict ordering.  For this reason, Maptool
generates the LIGA control directive:

     ORDER: TREE COMPLETE ;

   when it detects that one of these grammar mappings is required. 
The control directive indicates that the tree should be constructed
completely before any computations take place.

   The grammar mappings which cause Maptool to emit these directives
are the use of chain rules in the abstract syntax that do not exist in
the concrete syntax (*note Rule Matching::.) and any use of rule
mapping (*note Rule Mapping::.).  Aside from symbolic mappings (*note
Symbol Mapping::.) and the use of LISTOF constructs, the generated
concrete and abstract syntaxes need to be identical in order to allow
computations to take place during tree construction.


File: syntax,  Node: Abstraction,  Next: Expression,  Prev: Constraints,  Up: Hints

Abstracting information from literals
-------------------------------------

   Literal terminals often distinguish phrases whose structures are
identical except for the particular literal terminal.  For example, in
a normal arithmetic expression the phrase describing addition and the
phrase describing subtraction are identical except for the literal `+'
or `-'.  Taking nonterminal equivalence classes into account, it may
be that *all* phrases representing operations with two operands are
identical except for the operator literal.

   When phrases have identical structure except for one or more
literals, the tree computations carried out at the nodes corresponding
to those phrases are often identical except for some parameter that
depends on the particular literal.  It is then useful to abstract from
the distinct literals, obtaining a single phrase with which to
associate the computation and a set of phrases with which to associate
the parameter evaluation.  The key point here is that in many cases
the computation will apply to a wide variety of translation problems,
whereas the particular set of literals characterizes a single
translation problem.  By abstracting from the distinct literals, the
computation can be reused.

   To abstract from a specific literal, simply replace that literal
with a nonterminal and add a production that derives the literal from
that nonterminal.  This added production represents the phrase with
which the parameter evaluation would be associated.  The computation
for the phrase in which the literal was replaced by the nonterminal
will now obtain the parameter value from the corresponding child,
rather than evaluating it locally.


File: syntax,  Node: Expression,  Prev: Abstraction,  Up: Hints

Mapping expressions for overload resolution
-------------------------------------------

   It is quite common for a single operator to have different meanings
that depend on the types of its operands.  For example, in Pascal the
operator `+' might mean integer addition, real addition or set union. 
There are well-known techniques for deciding what is meant in a
particular context, and these techniques depend only on the particular
set of operators and operand types.  The computations themselves are
parameterized by this information (*note Selecting an operator at an
expression node: (type)IdentifyOperator.).

   In order to reuse the tree computation to resolve overloading,
abstract from the particular set of literals that represent the
operators of the language.  Then define equivalence classes in which
every nonterminal representing an expression is replaced by `Expr' and
every nonterminal representing an operator by `Op'.  Finally,
associate the appropriate computations with the following rules:

     Expr: Expr Op Expr.
     Expr: Op Expr.
     Expr: Identifier.
     Expr: Integer.
     ...

(Here `...' indicates rules for other denotations, such as
floating-point numbers, `true', etc., defined in the language.)

   As an example of the process, consider a language with integer and
Boolean expressions in the style of Pascal.

* Menu:

* Con::	Description of the input text, abstracting operators
* Sym::	Description of the equivalence classes


File: syntax,  Node: Con,  Next: Sym,  Up: Expression

Description of the input text, abstracting operators
....................................................

   The literals that represent operators in this language are `+',
`-', `*', `/', `div', `mod', `and', `or' and `not'.  Define a new
nonterminal for each precedence level of the dyadic operators, one for
the unary arithmetic operators, and one for `not':

     Addop: '+' / '-' / 'or' .
     Mulop: '*' / '/' / 'div' / 'mod' / 'and' .
     Sign: '+' / '-' .
     Notop: 'not' .

These productions abstract from the literals, and embody the
information about the precedence and association (all operators are
left-associative) needed to determine the phrase structure.

   Using these new nonterminals, define the phrase structure of an
expression:

     SimpleExpression: Sign Sum / Sum .
     Sum: Sum Addop Term / Term .
     Term: Term Mulop Factor / Factor .
     Factor: Notop Factor / Primary .
     Primary: Integer / Id / 'true' / 'false' / '(' SimpleExpression ')' .

(Here `Integer' is a terminal representing arbitrary digit sequences
and `Id' is a terminal representing arbitrary identifiers.  These
symbols will be recognized by the lexical analyzer.)


File: syntax,  Node: Sym,  Prev: Con,  Up: Expression

Description of the equivalence classes
......................................

   All of the dyadic operators fall into the same equivalence class,
which should be represented by the symbol `Binop'.  `Sign' and `Notop'
both belong to the `Unop' class, and `SimpleExpression', `Sum',
`Term', `Factor', `Primary' are in the `Expr' class.  Here is a
type-`map' file defining these classes:

     MAPSYM
     Op ::= Addop Mulop Sign Notop .
     Expr ::= SimpleExpression Sum Term Factor Primary .

