This is Info file ptg, produced by Makeinfo-1.43 from the input file
/home/lukem/Dropbox/CAS/eli-4.8.1/Eli/pkg/ptg/ptg.tnf.


File: ptg,  Node: Top,  Up: (dir)

Pattern-Based Text Generator
****************************

   $Revision: 1.1 $

   The Pattern-Based Text Generator PTG supports translations into any
kind of structured text.  The structure of the target text is
described by a set of patterns.  PTG generates a set of functions for
them. They are called to compose an instance of the target structure
which is then output.

   PTG is suitable to produce any kind of target language, e. g.
programs of any programming language, special purpose languages like
TeX or PostScript, or just structured data or tables in textual form.

   PTG is typically applied for tasks of a language processor's
translation phase. The calls of the patterns functions are then used
in LIDO specifications to describe the translation of certain tree
contexts.  PTG may as well be used in C functions or in stand-alone C
programs that translate some data structure into an output text.

   Going into the node `Example' one can use the documentation
browser's `Run' command to obtain a copy of the complete specification
for the example described in this manual.

* Menu:

* Introduction::       Introduction to PTG
* Patterns::           Pattern Specifications
*    Indexed::         Indexed Insertion Points
*    Typed::           Typed Insertion Points
*    Calls::           Function Call Insertion
*    Optional::        Marking Patterns as optional
* Output::             Output Functions
* Techniques::         Some Useful Techniques
*    Data::            Output of Data Items
*    Identifiers::     Generating Identifiers
*    Sequences::       Output of Sequences
* Example::            A Complete Example
*    Structure::       Source Language Structure
*    Frame::           Program Frame
*    Expressions::     Expressions
*    CHAIN::           Using LIDO CHAINs
*    CONSTITUENTS::    Using LIDO CONSTITUENTS
* Predefined::         Predefined Entities
* Macros::             Influencing PTG Output
*    Postprocessing::  Changing Default-Output for Limited Line Length
* Outdated::           Outdated Constructs
* Syntax::             Syntax of PTG Specifications

* Index::         Index of this manual


File: ptg,  Node: Introduction,  Next: Patterns,  Prev: Top,  Up: Top

Introduction to PTG
*******************

   A PTG specification is a set of named patterns describing the
structure and textual components of an output text. They are contained
in files of type `.ptg'. PTG generates a C module `ptg_gen.[ch]' that
has one function for each pattern specified.  Calls of these functions
apply the patterns in order to compose an instance of the target text,
which can be output by a call of PTG's output functions.  Those
functions may be used in LIDO specifications or in C modules which
import the interface file of the generated module `ptg_gen.h'.

   Consider the following simple example: Assume we want to produce
parenthesized representations of binary trees like S-expressions in
LISP:

          ((1.nil).(2.(3.nil))

We specify three named patterns, one for the parenthesized structure,
one for the literal `nil', and one for numbers:

          Pair:   "(" $ "." $ ")"
          Nil:    "nil"
          Numb:   $ int

   For each of these patterns PTG generates a function which yields an
internal representation of a pattern application.  The following
nested calls produce the above output text:

        PTGOut (
          PTGPair (
             PTGPair(PTGNumb(1), PTGNil()),
                     PTGPair(PTGNumb(2), PTGPair(PTGNumb(3), PTGNil()))
             ));

Of course one may store intermediate results of pattern applications
and defer output until the target text is completely composed:

        n1 = PTGPair (PTGNumb (1), PTGNil ());
        n2 = PTGPair(PTGNumb(2), PTGPair(PTGNumb(3), PTGNil()));
        PTGOut (PTGPair (n1, n2));

   The benefits of using PTG can best be described by a comparison
with using C `printf' functions directly.  For the above example a C
program would contain statements like

        printf ("( %s. %s)", a, b);

where `a' and `b' are pointers to the strings to be inserted.

   Such a statement implements `what' text to be generated by the
format string and the arguments, `when' it is to be output by the
placement of the statement within the program, and `how' the text is
produced by format strings and output functions.

   PTG separates the issues `what' and `when' by the pattern
specifications (`what') and the function calls (`when'). The calls
produce an internal structure with all information necessary to output
the text, rather than immediately outputting it. PTG automatically and
efficiently implements the `how'.


File: ptg,  Node: Patterns,  Next: Output,  Prev: Introduction,  Up: Top

Pattern Specifications
**********************

   A pattern is specified by a named sequence of C string literals and
`$' tokens that denote insertion points, e.g.

        Pair: "(" $ "." $ ")" /* S-expression */

   C style comments may be inserted anywhere in a PTG specification.

   The pattern describes an output text that consists of the specified
sequence of strings with the results of pattern applications being
inserted at each insertion point.

   A pattern is applied by calling a PTG generated function that has
the name of the pattern preceded by `PTG', `PTGPair' in this case. The
result of such a call yields a pointer of type `PTGNode' which
represents that pattern application.

   The pattern function takes as many arguments of type `PTGNode' as
the pattern has insertion points. The arguments are obtained from
other calls of pattern functions. Their order corresponds to that of
the insertion points in the pattern.  (Alternative forms of are
described in *Note Indexed:: and *Note Typed::.)

   The pattern function for the example above has the following
signature:

        PTGNode PTGPair (PTGNode a, PTGNode b)

Examples for applications of this pattern are:

        x = PTGPair (PTGNil(), PTGNil());
        y = PTGPair (x, x);

Restrictions:
.............

   For every two patterns in all `.ptg' specifications, the following
condition must hold: If any two patterns are not equal, their names
must be different.  Additionally, the names of the patterns must not
collide with identifiers predefined for PTG.

   PTG does not insert any additional white space before or after
elements of the pattern sequence. Token separation and new line
characters (especially at the end of a file) have to be specified
explicitly.

* Menu:

*    Indexed::       Indexed Insertion Points
*    Typed::         Typed Insertion Points
*    Calls::         Function Call Insertion
*    Optional::      Marking Patterns as optional


File: ptg,  Node: Indexed,  Next: Typed,  Prev: Patterns,  Up: Patterns

Indexed Insertion Points
========================

   The insertion points of a pattern may be identified by numbers, e.g. 
`$1', `$2'. This facility allows to insert an argument of a pattern
function call at several positions in the pattern, and it allows to
modify patterns without the need to change their application calls.

   In the following example the first argument (the module name) is
inserted at two positions:

        Module: "module " $1 "\nbegin" $2 "end " $1 ";\n"

The pattern function is called with two arguments.

   The correspondence between insertion points and function parameters
is specified by the numbers of the insertion points, i.e. the first
argument is inserted at the insertion points `$1'.

   This facility also makes the calls of pattern functions more
independent of pattern modifications. For example, the following
pattern describing declarations

        Decl: $1 /* type */ " " $2 /* identifiers */ ";\n"

would be applied by a call `PTGDecl (tp, ids)', with the first argument
inserting the type and the second inserting the identifiers.  Those
calls are invariant against changing the pattern to Pascal-like
declaration style:

        Decl: $2 ":" $1 ";"

In the same way one variant of a pattern may omit an argument specified
in an other variant.

   In general a pattern may contain several occurrences of any of the
insertion point markers `$'i. There is practically no upper bound for
`$'i. The generated function has n parameters, where n is the maximal
i occurring in a `$'i of the pattern. The i-th function argument is
substituted at each occurrence of `$'i in the pattern.

   If a pattern does not mention all `$'i between `$1' and the maximum
`$'n, e.g. `$1' and `$3' but not `$2', the function has n parameters,
but some are not used.

Restrictions:
.............

   Indexed and non-indexed insertion points must not be mixed in a
single pattern.


File: ptg,  Node: Typed,  Next: Calls,  Prev: Indexed,  Up: Patterns

Typed Insertion Points
======================

   Data items can be inserted into the output text by specifying
insertion points to have one of the types `int', `string', `long',
`short', `char', `float' or `double', e.g.

        Matrix:  "float " $1 "[" $2 int "][" $3 int "];\n"

The generated pattern function has the following signature:

        PTGNode PTGMatrix (PTGNode a, int b, int c)
   Function calls must supply arguments of corresponding types.  They
are output in a standard output representation.

   Another typical application of typed insertion point is generating
identifiers:

        Ident: $ string $ int

This pattern may be used to compose identifiers from a string and a
number, e.g. a call `PTGIdent ("abc", 5)' producing `abc5'.  The
string item is often taken from the input of the language processor,
and the number is used to guarantee uniqueness of identifiers in the
output.  (This construct also substitutes the outdated leaf patterns,
*Note Outdated::.)

   A typical example for composition of output text fragments from
data of basic types is given by a pattern that produces German car
identifications:

        CarId: $ string $ string $int

which is applied for example by `PTGCarId ("PB-", "AB-", 127)'.

Restrictions:
.............

   If an indexed insertion point occurs multiply in a pattern its type
must be the same for all occurrences.


File: ptg,  Node: Calls,  Next: Optional,  Prev: Typed,  Up: Patterns

Function Call Insertion
=======================

   There are situations where it is inconvenient or impossible to
specify an output component by a pattern. In such cases calls of user
defined functions can be specified instead of insertion points in a
pattern.

   Assume as an example that indentation shall be specified for the
output of a block structured language:

        Block:   [NewLine] "{" [Indent] $1   /* declarations */
                                        $2   /* statements */
                               [Exdent]
                 [NewLine] "}"

This pattern for producing a block has two ordinary insertion points,
one for the declarations of the block and one for its statements. The
pattern function is called as usual with two corresponding arguments. 
When the output text is produced the user defined functions `NewLine',
`Indent', and `Exdent' are called in order to insert text at the
specified pattern positions.

   In this case the functions must have exactly one parameter that is
a `PTG_OUTPUT_FILE':

        extern void NewLine (PTG_OUTPUT_FILE f);
        extern void Indent (PTG_OUTPUT_FILE f);
        extern void Exdent (PTG_OUTPUT_FILE f);

The type `PTG_OUTPUT_FILE' can be supplied by the user.  If it is not,
a default is supplied by the generated file `ptg_gen.h'. The function
has to be implemented such that a call outputs the desired text to the
file pointed to by `f' by using some provided output macros, *Note
Macros::.

   Note: These function calls are executed when the output text is
produced.  The functions are not yet called when the patterns are
applied.  PTG guarantees that those calls occur in left-to-right order
of the produced output text. Hence, the above triple of functions may
use global variables to keep track of the indentation level.

   Functions, that support indentation ready to use in a PTG
specification can be found in the module library, *Note Indentation:
(output)Indent.

   Such function calls may also take arguments which are passed
through from the call of the pattern function. They are specified by
occurrences of insertion points within the call specification:

        Block:   [NewLine] "{" [Indent $3 int] $1   /* declarations */
                                               $2   /* statements */
                               [Exdent $3 int]
                 [NewLine] "}"

In this case the indentation depth is determined individually for each
application of the `Block' pattern which is called for example by
`PTGBlock (d, s, 3)'. The last argument is passed through to the calls
of `Indent' and `Exdent' which now must have the signatures

        extern void Indent (PTG_OUTPUT_FILE f, int i);
        extern void Exdent (PTG_OUTPUT_FILE f, int i);

   Note: The arguments supplied with a pattern application are stored
until the functions are called when the output is produced.

   In general several arguments may be specified to be passed through
to a function call. They may be typed by one of the types `int',
`string', `long', `short', `char', `float', `double' or `pointer'.  In
case of type `pointer' the supplied argument of the pattern function
call must have a pointer type that is defined for the corresponding
parameter of the user function.  If no type is specified an argument
of type `PTGNode' is passed through.

   Arguments specified of type `pointer' are typically used if the
translation of certain data structures by user specified functions is
to be inserted into pattern driven translations.


File: ptg,  Node: Optional,  Prev: Calls,  Up: Patterns

Optional Parts in Patterns
==========================

   Parts of a pattern can be marked as optional by surrounding them
with braces. Using this notation, the optional parts will only be
printed in the output, if all other insertions of the pattern
(insertions not marked optional by being included in a brace) produce
output.  This can be applied to simplify the construction of lists
considerably.

        CommaSeq:    $1 {", "} $2

   A call of the pattern function `PTGCommaSeq(a,b)' produces the
separator only if neither `a' nor `b' is empty; otherwise `a' and `b'
are just concatenated, leaving out the optional part. This facility is
especially useful if such separated lists are composed by pattern
function calls that occur in loops or in separated contexts. *Note
Example::, for a more sophisticated example.

   Note: The result of a pattern call is the unique value `PTGNULL' if
the empty output string is produced. (There is no way to further
inspect the intermediate results of pattern applications.) Certain
pattern constructs do not yield `PTGNULL' even if they may represent
empty strings:
   * Typed insertions and function call insertions,

   * empty strings and empty literals.  are considered not to be empty.

   Another example for optional parts in patterns is the following:
        Paren:       {"("} $ {")"}
   The pattern function `PTGParen(a)' will produce parentheses around
`a' if `a' is not empty. Otherwise, `PTGParen(a)' will be empty.

Restrictions:
.............

   An optional pattern is printed, if all non-optional insertions in
the node are not `PTGNULL'. However, if there are no non-optional
insertions, the braces are ignored and a warning is issued.

   It is possible to include more than one pattern in braces. Multiple
optional parts can be included in one Rule. However, the braces
marking an optional pattern cannot be used recursively inside an
optional pattern.


File: ptg,  Node: Output,  Next: Techniques,  Prev: Patterns,  Up: Top

Output Functions
****************

   PTG separates the composition of a target text from outputting it:
A target text is composed by calls of pattern functions.  They yield
results of type `PTGNode' representing the target text or fragments
thereof.

   There are three predefined PTG functions that can be applied to
`PTGNode' values in order to output the text. They have the following
signatures:

        PTGNode PTGOut(PTGNode r)
        PTGNode PTGOutFile(char *f, PTGNode r)
        PTGNode PTGOutFPtr(FILE *f, PTGNode r)

   A call `PTGOut (x)' writes the text represented by `x' to stdout.

   The function `PTGOutFile' takes the name of the output file as an
additional parameter. A call `PTGOutFile (n, x)' opens the file named
`n' for writing, writes the text represented by `x' to it, and closes
the file before returning.

   The function `PTGOutFPtr' takes the file pointer to an already open
file as additional parameter. A call `PTGOutFPtr (f, x)' writes the
text represented by `x' to `f', and leaves The function `PTGOutFPtr'
takes open upon exit.

   Each of the functions yields its `PTGNode' argument as result. 
Hence, nested calls of output functions may produce parts of the
complete target text on separate files, e.g.

        PTGOutFile ("f1",
           PTGModule (
              PTGOutFile ("f2", PTGInterface ( ...... )),
              PTGBody ( .... )))

In the above example a `Module' is composed by two text fragments
`Interface' and `Body'. The whole text is written to the file `f1'. The
`Interface' fragment is also written to the file `f2'.

   Of course nested calls like the above can be decomposed by storing
intermediate `PTGNode' values.  Nested calls of `PTGOutFile' to the
same file would destroy the results of the former calls.  Nested calls
of `PTGOutFPtr' to the same file would append the results of each call
to the end of the file.

   Note: Be aware that the output functions do not add a newline
character to the end of an output text. It has to be explicitly
specified by a pattern.  This behavior has been changed compared to
previous versions of PTG.  Adding a newline character to a text is
simply specified by a pattern like

          NewLine:    $ "\n"


File: ptg,  Node: Techniques,  Next: Example,  Prev: Output,  Up: Top

Some Useful Techniques
**********************

   This chapter describes some techniques that solve common tasks in
PTG applications.

* Menu:

* Data::         Output of Data Items
* Identifiers::  Generating Identifiers
* Sequences::    Output of Sequences


File: ptg,  Node: Data,  Next: Identifiers,  Up: Techniques

Output of Data Items
====================

   Usually data items like numbers, identifiers, or strings which are
computed by the translation process or taken from the input are to be
inserted into the output text at certain positions.  This is best
achieved by using typed insertion points as described in *Note Typed::.

   It is often necessary to convert single data items into a `PTGNode'
pointer to be used in pattern applications.  This can be achieved by
defining patterns for single data items:
        Number:    $ int
        String:    $ string
        StringLit: "\"" $ string "\""

Such patterns are applied by calls like `PTGNumber(5)',
`PTGString("+")', `PTGStringLit("Hello!")' producing the text items
`5', `+', and `"Hello!"' respectively.

   Predefined patterns for the conversion of single data items to
`PTGNode' pointers can also be found in a module of the specification
library, see also *note Commonly used Output patterns for PTG:
(output)PtgCommon..

   This module also solves the problem of generating a `PTGNode' that
generates a data item of the input text, e.g. identifiers or floating
point numbers, on output.


File: ptg,  Node: Identifiers,  Next: Sequences,  Prev: Data,  Up: Techniques

Generating Identifiers
======================

   Common techniques for producing identifiers are recommended
especially for translation into programming languages.  In the
simplest case identifiers are just reproduced from the input as shown
above. The following set of patterns allow to add prefixes or
postfixes to the original identifiers (see *Note Typed::):

        PointerId: "PTR_" $ string
        ValueId:   "VAL_" $ string
        UniqueId:  $ string $ int

Patterns like the first two may be used to generate different output
identifiers from one input identifier.  The last pattern allows to
attach a number to an identifier, e.g. to guarantee uniqueness in the
output in cases where the source and the target language have
different scope rules.

   Note: PTG does not add any white space between pattern items. 
Hence, patterns where identifiers or numbers may be inserted have to
ensure that the component tokens are separated, e.g.

        Decl: $ /* Type */ " " $ /* Ident */


File: ptg,  Node: Sequences,  Prev: Identifiers,  Up: Techniques

Output of Sequences
===================

   The construction of output text often requires to compose arbitrary
long sequences of items, e.g tokens, statements, or procedures.  Some
simple techniques for those tasks are described here.  The examples
can easily be generalized for similar applications.

   A generally applicable pattern for constructing sequences is

        Seq: $ $

An application

        PTGSeq (PTGString("."), PTGSeq (PTGString("."), PTGString(".")))

produces a sequence of 3 dots, assuming pattern `String' is suitably
defined.

   The following C loop computes a sequence of `n' dots:

        PTGNode dots = PTGNULL; int i;
        for (i=0; i<n; i++) dots = PTGSeq (dots, PTGString("."));

   Sequences where the items are separated by a certain string, e.g. a
comma or a space character can be specified by

        CommaSeq: $ {", "} $

An application

        PTGCommaSeq (PTGNumber (1), PTGNumber (2))

produces `1, 2', assuming pattern `Number' be suitably defined.

   The following C loop computes a comma separated sequence of the
numbers 1 to `n':

        PTGNode numseq = PTGNULL; int i;
        for (i=1; i<=n; i++)
          numseq = PTGCommaSeq (numseq, PTGNumber (i));


File: ptg,  Node: Example,  Next: Predefined,  Prev: Techniques,  Up: Top,  Eg: Run

A Complete Example
******************

   In this chapter we demonstrate the use of PTG for translating a
simple assignment language into C code.  This example shows PTG
techniques in the context of a complete translator specification. It
especially demonstrates how PTG patterns are applied in LIDO
specifications.

   When this manual is read online, the browser's `Run' command can be
used to obtain a copy of the complete specification for further
experiments.  You will get a Funnelweb file `PtgEx.fw' containing the
content of this chapter (*note top: (fw)top.).  It can be used for
example to derive the specified processor by

     PtgEx.fw :exe >.

or to derive the set of files described below:

     PtgEx.fw :fwGen >.

* Menu:

* Structure::    Source Language Structure
* Frame::        Program Frame
* Expressions::  Expressions
* CHAIN::        Using LIDO CHAINs
* CONSTITUENTS:: Using LIDO CONSTITUENTS



ptg
 

#!/bin/sh
echo "Obtaining specifications and sample input"
cp $ODINCACHE/PKGS/ptg/sample/PtgEx.fw PtgEx.fw
echo 'Copy complete, see file PtgEx.fw, hit return to continue'
read answer



File: ptg,  Node: Structure,  Next: Frame,  Up: Example

Source Language Structure
=========================

   Programs of this example language are sequences of assignments,
input statements, and output statements, like

   simple[1]==
        input a;
        output a;
        x := a + 1;
        y := x - 5;
        output x;
        output y + x;

     This macro is attached to a product file.

The values of variables and expressions are integral numbers.  There
are only the binary operators `+' and `-'.  The above program is to be
translated into the following C program:

   simple.out[2]==
        #include <stdio.h>
     
        int a = 0, x = 0, y = 0;
     
        int main (void) {
     
        scanf ("%d", &(a));
        printf ("%d\n",a);
        x = a+1;
        y = x-5;
        printf ("%d\n",x);
        printf ("%d\n",y+x);
     
        exit (0);
        }

     This macro is attached to a product file.

   The structure of the source programs is specified by the following
concrete grammar:

   Program.con[3]==
        Program:     Statement*.
     
        Statement:   Variable ':=' Expression ';'.
        Statement:   'input' Variable ';'.
        Statement:   'output' Expression ';'.
     
        Expression:  Expression Operator Operand / Operand.
     
        Operator:    '+' / '-'.
     
        Operand:     Variable.
        Operand:     IntLit.
        Variable:    Ident.

     This macro is attached to a product file.

   In the tree grammar `Expression's and `Operand's are represented
both by `Expression' nodes, as specified by the type `.sym' rule:

   Expr.sym[4]==
        Expression ::= Operand .

     This macro is attached to a product file.

   Identifier tokens, number literals, and comments are denoted as in
Pascal, as stated by the following type `.gla' specification:

   Mini.gla[5]==
        Ident:   PASCAL_IDENTIFIER
        IntLit:  PASCAL_INTEGER
                 PASCAL_COMMENT

     This macro is attached to a product file.


File: ptg,  Node: Frame,  Next: Expressions,  Prev: Structure,  Up: Example

Program Frame
=============

   In this section the overall structure of the target programs is
specified, the name of the output file is determined, and its contents
is produced by a PTG output function.  We first specify a pattern for
target program frame:

   Frame.ptg[6]==
        Frame:
           "#include <stdio.h>\n\n"
     
           $1 /* declarations */
     
           "\nint main (void) {\n\n"
     
           $2 /* statements */
     
           "\nexit (0);\n}\n"

     This macro is attached to a product file.

It has two insertion points, one for variable declarations and one for
the statement sequence.  The text to be inserted is obtained from the
attributes `Program.DeclPtg' and `Program.StmtPtg' of type `PTGNode'
It is shown below how they are computed.  Here they are used as
arguments of the `Frame' pattern application:

   TransProg.lido[7]==
        ATTR DeclPtg, StmtPtg: PTGNode;
     
        SYMBOL Program COMPUTE
          PTGOutFile (CatStrStr(SRCFILE, ".c"),
                      PTGFrame (THIS.DeclPtg, THIS.StmtPtg));
        END;

     This macro is attached to a product file.

   The above call of the output function `PTGOutFile' (see *note
Output::.) writes to a file which name is derived from the file name
of the source program by appending `".c"'. The concatenation function
is imported from the specification module library. See *Note String
Concatenation: (problems)Strings, for further details on the `Strings'
module.

   TransProg.specs[8]==
     $/Tech/Strings.specs

     This macro is attached to a product file.

   The macro `SRCFILE' is obtained from the source program module, see
*Note Text Input: (lib)source.  That module is included automatically
into every Eli specification. So, only it's interface has to be made
known by the attribute evaluator:

   TransProg.head[9]==
     #include "source.h"

     This macro is attached to a product file.


File: ptg,  Node: Expressions,  Next: CHAIN,  Prev: Frame,  Up: Example

Expressions
===========

   In this section we specify the translation of expressions.  Target
expressions are composed by applications of patterns that construct
the text in a bottom-up way, i.e. from the leaves up to the complete
expression.

   In our simple example this translation is one-to-one as specified
by the three patterns:

   TransExpr.ptg[10]==
        BinOperation: $ $ $
        Number:       $ int
        String:       $ string

     This macro is attached to a product file.

The `BinOperation' pattern composes a left operand, an operator, and a
right operand.  The `Number' pattern just converts an integral number
into text.  The `String' pattern reproduces its argument.  It is used
here for output of operators and of identifiers.

   These patterns are applied in computations of `Expression'
contexts. Attributes `Ptg' of type `PTGNode' are used for the
intermediate results:

   TransExpr.lido[11]==
        ATTR Ptg: PTGNode;
     
        RULE: Expression ::= Expression Operator Expression COMPUTE
           Expression[1].Ptg =
              PTGBinOperation (
                 Expression[2].Ptg, Operator.Ptg, Expression[3].Ptg);
        END;
     
        RULE: Operator ::= '+' COMPUTE
           Operator.Ptg = PTGString ("+");
        END;
     
        RULE: Operator ::= '-' COMPUTE
           Operator.Ptg = PTGString ("-");
        END;
     
        RULE: Expression ::= Variable COMPUTE
           Expression.Ptg = Variable.Ptg;
        END;
     
        RULE: Expression ::= IntLit COMPUTE
           Expression.Ptg = PTGNumber (IntLit);
        END;
     
        RULE: Variable ::= Ident COMPUTE
           Variable.Ptg = PTGString (StringTable (Ident));
        END;
     
        ATTR Sym: int;

     This macro is attached to a product file.

The last two computations use values obtained from named terminal
symbols: `IntLit' supplies an integer value to the `Number' pattern,
the token code of `Ident' is used to access the identifier string from
the `StringTable'.  The `String' pattern then reproduces the
identifier.


File: ptg,  Node: CHAIN,  Next: CONSTITUENTS,  Prev: Expressions,  Up: Example

Using LIDO CHAINs
=================

   In this sections the translation of statement sequences is shown. 
The LIDO `CHAIN' construct is used to compose a sequence of translated
statements in left-to-right order.

   Assignments, input statements, and output statements are translated
by the following patterns:

   TransStmt.ptg[12]==
        AssignStmt:  $1 /* lhs */ " = " $2 /* rhs */ ";\n"
        InputStmt:   "scanf (\"%d\", &(" $1 /* variable */ "));\n"
        OutPutStmt:  "printf (\"%d\\n\","  $1 /* expression */ ");\n"
     
        Seq:         $  $

     This macro is attached to a product file.

The last pattern is used to combine two text components (statement
sequences in this case) into one (see *Note Sequences::).

   A `CHAIN' named `StmtChn' is defined to compose `PTGNode's in
left-to-right order through the tree.  The `CHAIN' starts in the root
context with an empty text.  The result is obtained at the end of the
`CHAIN' by `TAIL.StmtChn':

   TransStChn.lido[13]==
        CHAIN StmtChn: PTGNode;
     
        SYMBOL Program COMPUTE
           CHAINSTART HEAD.StmtChn = PTGNULL;
           SYNT.StmtPtg = TAIL.StmtChn;
        END;

     This macro is attached to a product file.

   In each of the three statement contexts the translation is produced
by application of the corresponding pattern and appended to the end of
the `CHAIN' using the `Seq' pattern:

   TransStmt.lido[14]==
        RULE: Statement ::= Variable ':=' Expression ';' COMPUTE
           Statement.StmtChn = PTGSeq (Statement.StmtChn,
              PTGAssignStmt (Variable.Ptg, Expression.Ptg));
        END;
     
        RULE: Statement ::= 'input' Variable ';' COMPUTE
           Statement.StmtChn = PTGSeq (Statement.StmtChn,
              PTGInputStmt (Variable.Ptg));
        END;
     
        RULE: Statement ::= 'output' Expression ';' COMPUTE
           Statement.StmtChn = PTGSeq (Statement.StmtChn,
              PTGOutPutStmt (Expression.Ptg));
        END;

     This macro is attached to a product file.


File: ptg,  Node: CONSTITUENTS,  Prev: CHAIN,  Up: Example

Using LIDO CONSTITUENTS
=======================

   In this section the construction of a declarator sequence is
described using the LIDO `CONSTITUENTS' construct.  It is also shown
how a list with separators is produced, and how text is generated only
once for each identifier that occurs in the program.

   The source language does not have declarations; variables are
introduced by just using them.  Hence, we have to generate
declarations in the target program, one for each variable that occurs
in the source.

   A variable may occur several times, but its declaration must be
generated only once.  For that purpose each variable is identified by
a key which is associated to every occurrence of the variable.

   This task is an instance of a name analysis task. We can use the
`AlgScope' module of the module library to solve it:

   ScopeLib.specs[15]==
        $/Name/AlgScope.gnrc:inst

     This macro is attached to a product file.

   The computational role `IdDefScope' provided by that module is
associated to the grammar symbol `Variable':

   Scope.lido[16]==
        SYMBOL Variable INHERITS IdDefScope COMPUTE
           SYNT.Sym = TERM;
        END;

     This macro is attached to a product file.

   The computations of that module yield an attribute `Variable.Key'. 
It has the same value for each occurrence of a variable identifier.

   We now associate a property `IsDeclared' to variables by a type
`.pdl' specification:

   Decl.pdl[17]==
        IsDeclared: int;

     This macro is attached to a product file.

It describes a state of that variable with respect to the translation
process: A declaration is only produced if `IsDeclared' is not yet
set, and then `IsDeclared' is set.  The attribute `Variable.DeclPtg'
takes the result, either the generated target declaration or `PTGNULL'.

   VarDecl.lido[18]==
        RULE: Variable ::= Ident COMPUTE
           Variable.DeclPtg =
              IF (GetIsDeclared (Variable.Key, 0),
                  PTGNULL,
                  ORDER (ResetIsDeclared (Variable.Key, 1),
                         PTGDeclVariable (StringTable (Ident))));
        END;

     This macro is attached to a product file.

The pattern `DeclVariable' is used here to reproduce the variable name
from the `StringTable' and to add the initialization to it: A single
variable declarator is specified by the pattern

   Decl.ptg[19]==
        DeclVariable:  $ string " = 0"
        Declaration:   "int " $ ";\n"

     This macro is attached to a product file.

The second pattern constitutes a complete declaration where the
declarator list is inserted.

   The declarator list is collected in the `Program' context using a
`CONSTITUENTS' construct.  It combines the `PTGNode' values of all
`Variable.DeclPtg' attributes of the tree:

   ProgDecl.lido[20]==
        SYMBOL Program COMPUTE
           SYNT.DeclPtg =
              PTGDeclaration (
                 CONSTITUENTS Variable.DeclPtg
                 WITH (PTGNode, PTGCommaSeq, IDENTICAL, PTGNull));
        END;

     This macro is attached to a product file.

   The `WITH' clause of the `CONSTITUENTS' construct specifies the
type of the combined values, `PTGNode', and three functions which are
applied to obtain the resulting value: `PTGNull' is the nullary
predefined function producing no text.  `IDENTICAL' is a unary
function predefined in LIDO; it is applied to each `Variable.DeclPtg'
attributes reproducing its value.  `PTGCommaSeq' is a pattern function
that combines two PTG texts, and separates them by a comma  if none of
them is empty.  That pattern is specified using PTG's optional clause
(see *Note Sequences::):

   Comma.ptg[21]==
        CommaSeq:  $ {", "} $

     This macro is attached to a product file.


File: ptg,  Node: Predefined,  Next: Macros,  Prev: Example,  Up: Top

Predefined Entities
*******************

   PTG generates a C module consisting of an interface file `ptg_gen.h'
and an implementation file `ptg_gen.c'.  The interface file exports
definitions for the following identifiers:
`PTGNode'
     the pointer type for internal representations of pattern
     applications;

`PTGNULL'
     a pointer of type `PTGNode' representing no text; Note: There are
     many ways to represent no text; comparing a `PTGNode' to
     `PTGNULL' is only a pointer comparison;

`PTGNull()'
     a macro without parameters that yields `PTGNULL', to be used
     where a function notation is needed, as in `WITH' clauses of
     LIDO's `CONSTITUENTS' construct;

`void PTGFree (void)'
     a call of this function deallocates all data generated by pattern
     applications; to be used for reduction of dynamic memory usage in
     cases where output is produced in several phases.

   The following functions can be used to process the contents of a
`PTGNode' and it's insertions recursively into an output file. These
functions are only available, under certain preconditions, *Note
Macros::.

`PTGNode PTGOut (PTGNode root)'
     a function that outputs the text represented by the parameter
     `root' to standard output

`PTGNode PTGOutFile (char *filename, PTGNode root)'
     a function that opens a file with the name given by the parameter
     `filename', outputs the text represented by the parameter `root',
     and closes the file

`PTGNode PTGOutFPtr (FILE *output, PTGNode root)'
     a function that expects the parameter `output' to be a file which
     is open for writing, outputs the text represented by the
     parameter `root' to the file, and leaves the file open

`PTGNode PTGProcess (PTG_OUTPUT_FILE file, PTGNode root)'
     a function that expects the parameter `file' to be of a type that
     is provided by the user, *Note Macros::.  If the default
     definition of `PTG_OUTPUT_FILE' is overriding, only `PTGProcess'
     can be used as output function; the other three output functions
     are not available in that case.

   The user should ensure that these predefined identifiers do not
clash with other definitions in the application importing the
interface file.  In particular, the pattern names should be chosen
such that prefixing them with `PTG' does not yield a predefined name,
e.g. a pattern name `Free' would be a bad choice.

   The implementation file contains external references to any user
defined function mentioned in the particular specification.


File: ptg,  Node: Macros,  Next: Outdated,  Prev: Predefined,  Up: Top

Influencing PTG Output
**********************

   The usage of PTG Patterns functions is a very flexible way to
construct the output of a program. However, some desirable effects can
not be achieved using pattern functions only:
*Pretty Printing*
     A pattern function does not have access to the current column
     position. Therefore, it cannot know where to insert line breaks to
     get the output formatted properly.

*Output destination*
     It can be desirable to write the output of PTG patterns to a
     destination other than a file, for example to redirect the output
     into a string buffer or to postprocess the output through a
     filter.

   To solve such tasks, PTG does not write its output directly into a
file. Instead, a set of macros is defined that can be adjusted to
change the behavior of PTG. If these macros are not defined, PTG
supports default definitions that process the contents of a `PTGNode'
into a named file or a given file pointer. In the following, those
macros are explained and small examples are given:

`PTG_OUTPUT_FILE'
     This macro defines the type name of the `file' parameter of the
     other macros, the output functions defined in *Note Output::, and
     the function call insertions. If no definition is supplied, its
     value is defined to be `FILE *'. Its value must be assignable by
     the C-operator `='. If the definition of `PTG_OUTPUT_FILE' is
     changed, a suitable definition for `PTG_OUTPUT_STRING' must also
     be provided.

`PTG_OUTPUT_STRING(file,param)'
     This macro is called to write a string value into an output file. 
     It is used by default for every text written by PTG.  Hence,
     redefining this macro suffices to change the default behavior of
     PTG, for instance to support pretty printing.  This macro has to
     be redefined if `PTG_OUTPUT_FILE' is redefined.

`PTG_OUTPUT_INT(file,param)'
`PTG_OUTPUT_SHORT(file,param)'
`PTG_OUTPUT_LONG(file,param)'
`PTG_OUTPUT_CHAR(file,param)'
`PTG_OUTPUT_FLOAT(file,param)'
`PTG_OUTPUT_DOUBLE(file,param)'
     These macros are used to write typed insertions into an output
     file. By default, they are set up in a way that they convert
     their second argument into a string and call `PTG_OUTPUT_STRING'
     to process the output. So, when redefining `PTG_OUTPUT_FILE', you
     need not to supply a definition for these macros.

     Of course, there may be more efficient ways to output values of
     the various data types other than to convert them into strings
     and send the result to the string handling function. If you want
     to supply such an alternative for writing characters, for
     example, redefine the default behavior of `PTG_OUTPUT_CHAR' to
     print the character directly. These macros are provided for
     efficiency purposes only.

   To override the default implementations for these macros, implement
a substitution function in a type `.c' file. Include the file
`ptg_gen.h' to supply your new function with definitions for the other
macros, especially `PTG_OUTPUT_FILE'. Write cpp directives that define
the desired macro(s) into a type `.ptg.phi' file and include it in
your specification. Eli will then concatenate all those definitions
and supply it as a header file `ptg.h' to your processor.

   As an application of these macros, the following section shows a
simple and easy way to implement pretty printing of the output
generated by PTG.

* Menu:

* Postprocessing::      Changing Default Output for Limited Line Length


File: ptg,  Node: Postprocessing,  Prev: Macros,  Up: Macros,  Eg: Run

Changing Default Output for Limited Line Length
===============================================

   Sometimes it is necessary to postprocess PTG generated output. For
example, the length of the generated output lines may be limited by an
upper bound, so that certain restricted tools can process the output. 
Without postprocessing of the output, there is no way to determine the
current position in a line for a PTG structure being written.  Hence,
we adapt the definitions of the output macros to solve that task.

   As all output is finally handled by the macro `PTG_OUTPUT_STRING',
it is sufficient to modify it such that it controls the current
position in the line. With some more effort, it would be possible do
complete line breaking by buffering one line of output and looking for
suitable break points when the end of the line is encountered.

   The following code keeps track of the current column position and
implements a function, that conditionally inserts a line break if the
line is longer than 65 chars.

   linepos.c[22]==
     #include <string.h>
     #include "ptg_gen.h"
     
     static col = 0;
     
     void InitCol(void)
     {
        col = 0;
     }
     
     void OutputLine(FILE *f, char *s)
     {
        int l;
        char *nl;
     
        if (!s) return;
     
        l = strlen(s);
        nl = strrchr(s, '\n');
     
        if (!nl)
           col += l;
        else
           col = (l - 1 - (nl - s));
        fputs(s, f);
     }
     
     void CondNl(FILE *f)
     {
        if (col > 65)
           OutputLine(f, "\n");
     }

     This macro is attached to a product file.

   The function `InitCol' serves as initialization, if more than one
output file should be generated.  The function `CondNl' inserts a line
break, if the current line is longer than 65 characters.  The function
`OutputLine' overrides the default implementation of
`PTG_OUTPUT_STRING'.

   linepos.ptg.phi[23]==
     #define PTG_OUTPUT_STRING(file,param) OutputLine(file,param)

     This macro is attached to a product file.

   This can be used for example in the following PTG specification:

   linepos.ptg[24]==
     CommaSeq:       $ ", " [CondNl] $

     This macro is attached to a product file.

   Now, in a large iteration of calls to `PTGCommaSeq()', a line break
is inserted automatically, if a line exceeds 65 characters.

   To obtain a copy of the attached files in the current directory,
press the Run button.



ptg
 

#!/bin/sh
echo "Copying linepos-specification"
if test -f linepos.c -o -f linepos.ptg.phi -o -f linepos.ptg
then echo "*** Destination files already exist. Press return to continue"
else cp $ODINCACHE/PKGS/ptg/sample/linepos.* .
     echo "Ready. Press return to continue"
fi
read answer



File: ptg,  Node: Outdated,  Next: Syntax,  Prev: Macros,  Up: Top

Outdated Constructs
*******************

   The present version of PTG does not contain any outdated constructs. 
The leaf pattern facility which was marked as outdated in previous
versions of Eli has been deimplemented.


File: ptg,  Node: Syntax,  Next: Index,  Prev: Outdated,  Up: Top

Syntax of PTG Specifications
****************************

     PTGSpec:        PatternSpec+
     
     PatternSpec:    PatternName ':' (Item | Optional)*
     
     PatternName:    Identifier
     
     Item:           CString | Insertion | FunctionCall
     
     Insertion:      '$' [ Number ] [ Type ]
     
     FunctionCall:   '[' Identifier Arguments ']'
     
     Arguments:      Insertion*
     
     Type:           'int' | 'string' | 'pointer' | 'long' | 'short'
                     | 'char' | 'float' | 'double'
     
     Optional:       '{' Item+ '}'

   `Identifier' and `CString' tokens are denoted as in C.  `Number'
tokens consist of decimal digits.  Comments are written in C style. 
Line comments starting with `#' are also accepted.

   Note: A `CString' token may only extend over several lines if all
but the last line end with a backslash character.  An error message
like `illegal newline in string literal' indicates a violation of that
rule.

   The following additional alternative for `PatternSpec' defines leaf
patterns. This construct is outdated and is no longer accepted by PTG:

     PatternSpec:    PatternName ':' Type+ '[' [ Identifier ] ']'

If you have old specifications that use this pattern style, rewrite
them by pattern specifications as describe above, e.g.

        MyLeaf:   int string []
        YourLeaf: int string [YourFct]

should be rewritten into

        MyLeaf:   $ int $ string
        YourLeaf: [YourFct $ int $ string]


File: ptg,  Node: Index,  Prev: Syntax,  Up: Top

Index
*****

* Menu:

* A Complete Example:                   Example.
* C module:                             Introduction.
* CHAIN:                                CHAIN.
* CONSTITUENTS:                         CONSTITUENTS.
* Expressions:                          Expressions.
* Function Call Insertion:              Calls.
* Generating Identifiers:               Identifiers.
* Indexed Insertion Points:             Indexed.
* Introduction:                         Introduction.
* LIDO:                                 CONSTITUENTS.
* LIDO:                                 CHAIN.
* LIDO:                                 Expressions.
* LIDO:                                 Example.
* Leaf Pattern:                         Outdated.
* Outdated Constructs:                  Outdated.
* Output Functions:                     Output.
* Output of Data Items:                 Data.
* Output of Sequences:                  Sequences.
* PTG:                                  Top.
* PTGFree:                              Predefined.
* PTGNULL:                              Predefined.
* PTGNode:                              Predefined.
* PTGNode:                              Output.
* PTGNode:                              Typed.
* PTGNode:                              Patterns.
* PTGNull:                              Predefined.
* PTGOut:                               Predefined.
* PTGOut:                               Output.
* PTGOutFPtr:                           Predefined.
* PTGOutFPtr:                           Output.
* PTGOutFile:                           Predefined.
* PTGOutFile:                           Output.
* PTGProcess:                           Predefined.
* Pattern Specifications:               Patterns.
* Pattern-Based Text Generator:         Top.
* Predefined Entities:                  Predefined.
* Program Frame:                        Frame.
* SRCFILE:                              Frame.
* Source Language Structure:            Structure.
* StringTable:                          Expressions.
* Syntax of PTG Specifications:         Syntax.
* Typed Insertion Points:               Typed.
* Using LIDO CHAINs:                    CHAIN.
* Using LIDO CONSTITUENTS:              CONSTITUENTS.
* WITH functions:                       CONSTITUENTS.
* char:                                 Typed.
* comments:                             Syntax.
* comments:                             Patterns.
* declarations:                         CONSTITUENTS.
* double:                               Typed.
* example:                              Example.
* example language:                     Structure.
* exported identifiers:                 Predefined.
* file name:                            Frame.
* float:                                Typed.
* floating point numbers:               Data.
* function signature:                   Calls.
* function signature:                   Typed.
* function signature:                   Patterns.
* identifier:                           Identifiers.
* identifiers:                          Syntax.
* identifiers:                          Data.
* identifiers:                          Typed.
* indentation:                          Calls.
* insertion point:                      Typed.
* insertion point:                      Indexed.
* insertion point:                      Patterns.
* int:                                  Data.
* int:                                  Typed.
* interface file:                       Predefined.
* interface file:                       Introduction.
* list:                                 Sequences.
* long:                                 Typed.
* newline:                              Syntax.
* newline:                              Output.
* numbers:                              Data.
* optional output patterns:             Optional.
* output function:                      Frame.
* passed through arguments:             Calls.
* pattern:                              Patterns.
* pattern function:                     Patterns.
* pointer:                              Calls.
* printf:                               Introduction.
* ptg_gen.c:                            Introduction.
* ptg_gen.h:                            Predefined.
* ptg_gen.h:                            Introduction.
* separator:                            CONSTITUENTS.
* separator:                            Sequences.
* sequence:                             Sequences.
* sequences:                            CONSTITUENTS.
* sequences:                            CHAIN.
* short:                                Typed.
* statements:                           CHAIN.
* string:                               Syntax.
* string:                               Data.
* string:                               Typed.
* tokens:                               Syntax.
* unique pattern names:                 Patterns.
* user supplied function:               Calls.
* white space:                          Identifiers.
* white space:                          Patterns.



Tag Table:
Node: Top126
Node: Introduction2313
Node: Patterns4811
Node: Indexed6833
Node: Typed8816
Node: Calls10274
Node: Optional13868
Node: Output15847
Node: Techniques18138
Node: Data18471
Node: Identifiers19680
Node: Sequences20758
Node: Example22040
Node: Structure23245
Node: Frame25250
Node: Expressions27248
Node: CHAIN29396
Node: CONSTITUENTS31504
Node: Predefined35311
Node: Macros37915
Node: Postprocessing41510
Node: Outdated44343
Node: Syntax44635
Node: Index46185

End Tag Table
