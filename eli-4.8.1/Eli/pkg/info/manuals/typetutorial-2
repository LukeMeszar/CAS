This is Info file typetutorial, produced by Makeinfo-1.43 from the
input file
/home/lukem/Dropbox/CAS/eli-4.8.1/Eli/pkg/info/tnf/typetutorial.tnf.


File: typetutorial,  Node: Union,  Next: Functions,  Prev: Array,  Up: Top

Union Types
***********

We introduce union types to our language in order to demonstrate how
subtype relations and their coercions are specified.  A union type is
described by a sequence of type denotations, which constitute the
subtypes of the specified union type.  A value of one of the subtypes
can be coerced to the union type.  A value of a union type can be
treated as a value of one of the subtypes using a cast operation or a
case statement.

Here is an example program that defines and uses a union variable
named `rv':

UnionExamp[75]==
     begin
       var   union int, bool end rv;
       var   int j, bool c;
       rv = 42; rv = true;
       j = <int> rv;
       case rv of
         int t: j = t;
         bool t: c = t;
       end
     end

     This macro is attached to a product file.

In the `case' statement the `case' expression has a union type. Each
case declares a variable of a subtype of that union type. The branch
which corresponds to the current type of the `case' expression is
selected, its variable is initialized with the value of the `case'
expression, and the statement is executed.

The following productions describe union types, type casts, and `case'
statements: Abstract union syntax[76]==
     RULE: TypeDenoter ::= UnionType END;
     RULE: UnionType  ::= 'union' UnitedTypes 'end' END;
     RULE: UnitedTypes LISTOF UnitedType END;
     RULE: UnitedType ::= TypeDenoter END;
     
     RULE: Expression ::= '<' TypeDenoter '>' Expression END;
     
     RULE: Statement ::= CaseStmt END;
     RULE: CaseStmt ::= 'case' Expression 'of' Cases 'end' END;
     RULE: Cases LISTOF Case END;
     RULE: Case ::= ObjDecl ':' Statement END;

     This macro is invoked in definition 88.

The following computations introduce a type denoter for union types
and associate properties for test output to it: In order to check
whether a type is a union type, as required for example in a case
statement, we introduce a property `IsUnionType'.  Is union type[77]==
     IsUnionType: int;

     This macro is invoked in definition 87.

Union type denoter[78]==
     SYMBOL UnionType INHERITS TypeDenotation END;
     
     RULE: UnionType ::= 'union' UnitedTypes 'end' COMPUTE
       .GotTypeProp =
           ORDER (
             ResetIsUnionType (UnionType.Type, 1),
             ResetTypeName (UnionType.Type, "union..."),
             ResetTypeLine (UnionType.Type, LINE));
     END;
     
     RULE: TypeDenoter ::= UnionType COMPUTE
       TypeDenoter.Type = UnionType.Type;
     END;

     This macro is invoked in definition 88.

For the comparison of union types stuctural equivalence is specified,
such that the fact that it is a union type and the sequence of
subtypes are relevant for type equality.  `UnionClass' is the the set
containing all union types for initialization of the equivalence check.

Union type class[79]==
     UnionClass;

     This macro is invoked in definition 87.

The `UnionClass' and the sequence `UnitedTypes.OpndTypeList' are used
as arguments of `AddTypeToBlock' to specify type equivalence of union
types. Property `ComponentTypes' is set accordingly:

Union type equality computation[80]==
     RULE: UnionType ::= 'union' UnitedTypes 'end' COMPUTE
       UnionType.GotType =
           AddTypeToBlock
             (UnionType.Type, UnionClass,
              VResetComponentTypes (UnionType.Type, UnitedTypes.OpndTypeList))
           <- .GotTypeProp;
     END;
     
     SYMBOL UnitedTypes INHERITS OpndTypeListRoot END;
     SYMBOL UnitedType  INHERITS OpndTypeListElem END;
     
     RULE: UnitedType ::= TypeDenoter COMPUTE
       UnitedType.Type = TypeDenoter.Type;
       UnitedType.DefTableKeyElem = UnitedType.Type;
     END;

     This macro is invoked in definition 88.

Note, that here the order of the subtypes in the type denoter is
relevant for type equality. If that is not desired, one could for
example sort the list of the component types in a canonical order
before using it as an argument of `AddTypeToBlock'.

For each union type we introduce two groups of conversion operators: A
widening coercion from each subtype type to the union type, and a down
cast from the union type to each subtype.  For the latter an
indication has to be introduced: Downcast indication[81]==
     DownCast;
     UnionWiden;

     This macro is invoked in definition 87.

As a pair of operators has to be introduced for each subtype, the
context of the subtype denoter is the right place to do it.  The
coercion operator is not created explicitly; it is only stated that
the subtype is `Coercible' to the union type. The down cast conversion
is introduced as a `MonadicOperator':

Widening coercion computation[82]==
     SYMBOL UnitedType INHERITS OperatorDefs COMPUTE
       SYNT.GotOper =
         ORDER
           (Coercible (UnionWiden, THIS.Type, INCLUDING UnionType.Type),
            MonadicOperator
             (DownCast, NewKey(),
              INCLUDING UnionType.Type, THIS.Type));
     END;

     This macro is invoked in definition 88.

The context of the down cast construct imposes a requirement on the
type of the operand expression.  Any conversion operator of the
`DownCast' indication can be applied to the operand expression, in
addition to any coercions, to satisfy this requirement:

Down cast[83]==
     RULE: Expression ::= '<' TypeDenoter '>' Expression COMPUTE
       CastContext (Expression[1], , Expression[2], TypeDenoter.Type);
       Indication (DownCast);
     END;

     This macro is invoked in definition 88.

In a `case' statement it is required that the `case' expression has a
union type:

Union case statement[84]==
     SYMBOL CaseStmt: Type: DefTableKey;
     
     RULE: CaseStmt ::= 'case' Expression 'of' Cases 'end' COMPUTE
       CaseStmt.Type = Expression.Type;
     
       IF (NOT (GetIsUnionType (Expression.Type, 0)),
       message (ERROR, "Case expression must have a union type",
                0,COORDREF))
       <- INCLUDING Program.TypeIsSet;
     END;

     This macro is invoked in definition 88.

Each branch of a `case' statement forms a range for the declaration of
the variable that gets the value of the `case' expression if that case
is selected.  It is required that the type of the variable is a
subtype of the type of the case expression.  We here require that it
is coercible to the type of the `case' expression, although that is
not quite exact.  Union case[85]==
     SYMBOL Case INHERITS RangeScope END;
     
     RULE: Case ::= ObjDecl ':' Statement COMPUTE
       IF (NOT (IsCoercible
                  (ObjDecl.Type, INCLUDING CaseStmt.Type)),
       message (ERROR, "Must be a subtype of the case expression",
                0, COORDREF))
       <- INCLUDING Program.GotType;
     END;

     This macro is invoked in definition 88.

In other contexts `ObjDecl' occurs in a CHAIN.  To avoid an error
message on missing a chain start we apply the role `OpndTypeListRoot'
here, which has the CHAINSTART, although that role is not needed:

Union CHAIN workaraound[86]==
     SYMBOL Cases INHERITS OpndTypeListRoot END;

     This macro is invoked in definition 88.

Union.pdl[87]==
     Is union type[77]
     Union type class[79]
     Downcast indication[81]

     This macro is attached to a product file.

Union.lido[88]==
     Abstract union syntax[76]
     Union type denoter[78]
     Union type equality computation[80]
     Widening coercion computation[82]
     Down cast[83]
     Union case[85]
     Union case statement[84]
     Union CHAIN workaraound[86]

     This macro is attached to a product file.

Union.con[89]==
     Concrete union syntax[144]

     This macro is attached to a product file.


File: typetutorial,  Node: Functions,  Next: Type3,  Prev: Union,  Up: Top

Functions
*********

This chapter introduces definitions and calls of parameterized
functions. Type analysis has to check that the signature of a function
call matches the signature of the called function, and that functions
return a value of the specified type.

Here is an example program that defines some functions.  The grammar
for function calls and return statements is given below.

FunctionExamp[90]==
     begin
       var   int i, int j,
             bool b, bool c,
             real r, real s;
     
       fun f (int x, real y) real
       begin r = x * y; return r;end;
     
       fun g (real z) void
       begin r = z; return; end;
     
       s = f (i+1, 3.4);
       g (f (j, s));
       return;
     end

     This macro is attached to a product file.

We first extend the grammar by productions for function declarations:
Abstract function syntax[91]==
     RULE: Declaration ::=  FunctionDecl END;
     RULE: FunctionDecl ::= 'fun' DefIdent Function ';' END;
     RULE: Function ::=     FunctionHead Block END;
     RULE: FunctionHead ::= '(' Parameters ')' TypeDenoter END;
     RULE: Parameters LISTOF Parameter END;
     RULE: Parameter ::= TypeDenoter DefIdent END;

     This macro is invoked in definition 100.

A function type is characterized by its signature, i.e.  the sequence
of the types of its parameters and the result type.  (Note: If we had
more than one mode of parameter passing, the abstraction of a
parameter in the function signature would be a pair: parameter passing
mode and parameter type.)

We first consider the name analysis aspect of a function declaration:
The `Function' subtree is a range where the parameter definitions are
valid. The function `Block' is nested in that range. Since the
`DefIdent's of parameters are already completely specified for name
analysis, we need only:

Function range[92]==
     SYMBOL Function INHERITS RangeScope END;

     This macro is invoked in definition 100.

Now we consider a function declaration as a definition of a typed
entity, and apply the same specification pattern as used for variable
declarations.  Furthermore, each `Parameter' is also a
`TypedDefinition'.  There is no problem in nesting definitions of
typed entities this way.

Function declaration types[93]==
     SYMBOL FunctionDecl INHERITS TypedDefinition END;
     
     RULE: FunctionDecl ::= 'fun' DefIdent Function ';' COMPUTE
       FunctionDecl.Type = Function.Type;
     END;
     
     RULE: Function ::= FunctionHead Block COMPUTE
       Function.Type = FunctionHead.Type;
     END;
     
     SYMBOL Parameter INHERITS TypedDefinition END;
     
     RULE: Parameter ::= TypeDenoter DefIdent COMPUTE
       Parameter.Type = TypeDenoter.Type;
     END;

     This macro is invoked in definition 100.

Next, we specify how the type of a function is composed.  The
`FunctionHead', which contains the signature, is treated as a
`TypeDenotation' for a function type.

Function type[94]==
     SYMBOL FunctionHead INHERITS TypeDenotation, OperatorDefs END;

     This macro is invoked in definition 100.

Furthermore, a function declaration introduces an operator.  This is
indicated by the role `OperatorDefs'.  The computation `ListOperator'
creates a new operator, identified by `FunctionHead.Type'.  The types
of the parameters together with the result type `TypeDenoter.Type'
form its signature.

Function signature[95]==
     RULE: FunctionHead ::= '(' Parameters ')' TypeDenoter COMPUTE
       FunctionHead.GotOper +=
          ListOperator (
            FunctionHead.Type,
            FunctionHead.Type,
            Parameters.OpndTypeList,
            TypeDenoter.Type);
     END;
     
     SYMBOL Parameters INHERITS OpndTypeListRoot END;
     SYMBOL Parameter INHERITS OpndTypeListElem END;
     
     RULE: Parameter ::= TypeDenoter DefIdent COMPUTE
       Parameter.DefTableKeyElem = TypeDenoter.Type;
     END;

     This macro is invoked in definition 100.

Function calls are integrated in the expression syntax of our
language. We chose a very general form of an `Expression' to denote
the function to be called. That allows us to later expand the language
by expressions which yield a function.  That feature does not create
additional problems for type analysis.

We also introduce return statements into our language:

Abstract call syntax[96]==
     RULE: Expression ::=    Expression '(' Arguments ')' END;
     RULE: Arguments  LISTOF Argument END;
     RULE: Argument   ::=    Expression END;
     
     RULE: Statement  ::=    'return' ';' END;
     RULE: Statement  ::=    'return' Expression ';' END;

     This macro is invoked in definition 100.

Type analysis for a function call is straight-forward: A call is
treated as an operation which takes the arguments as operands.
`Expression[2]' yields the function to be called. Its type provides
the operator indication, which may be overloaded with several
operations, as stated in the context of the function definition.  The
precoined computation `ListContext' connects the expression subtree of
the arguments with `Expression[1]' representing the result.

Call types[97]==
     SYMBOL Arguments INHERITS OpndExprListRoot END;
     SYMBOL Argument INHERITS OpndExprListElem END;
     
     RULE: Expression ::= Expression '(' Arguments ')' COMPUTE
       ListContext (Expression[1], , Arguments);
       Indication (Expression[2].Type);
     
       IF(BadOperator,
         message
           (ERROR,
            "Call does not match the functions' signatures",
            0, COORDREF));
     END;

     This macro is invoked in definition 100.

The following context connects the `Argument' node with the expression
subtree forming the actual parameter.  If they had the same type
properties, we would have used a `TransferContext' computation.
However, in our language we want to allow that the type of the
`Expression' need not match exactly the type required for the
`Argument' as specified in the signature of the function. As in
assignments it shall be allowed that the expression yields a value of
type `real' which then is converted to an `int' value if required by
the function signature, e.g. in `f(3.4)'.

Hence, we use a `ConversionContext' which allowes to connect the
`Argument' via an operator with the `Expression' node. The indication
`assignOpr' is specified for this context. It states that the same
conversion operators as in assignments (i.e. `rToi') and all coercion
operators (i.e. `iTor') may be used to convert the result of the
`Expression' to the type of the `Argument', if necessary:

Arguments[98]==
     RULE: Argument ::= Expression COMPUTE
       ConversionContext (Argument, , Expression);
       Indication (assignOpr);
     END;

     This macro is invoked in definition 100.

A return statement refers to the immediately enclosing function
declaration. It has to be checked that a value of a type is returned
that is compatible to the result type, if the latter is not `void'.  A
return from the outermost program level is considered as if the
program was a `void' function.  Conversions that are additionally
applicable are specified in the same way as in the `Argument' context
above.

The attribute value `Function.ResultType' stems from the context of a
type denotation. Hence, its value may not be used directly in a
compare with a type key as `voidType'. The function `FinalType' has to
access the related type key, and the precondition `INCLUDING
Program.TypeIsSet' has to be stated.

Return statements[99]==
     ATTR ResultType: DefTableKey;
     
     RULE: Statement ::= 'return' Expression ';' COMPUTE
       RootContext (
         INCLUDING (Function.ResultType, Program.ResultType), , Expression);
       Indication (assignOpr);
     END;
     
     RULE: Statement ::= 'return' ';' COMPUTE
       IF (NOT (EQ (voidType,
                    FinalType (
                       INCLUDING (Function.ResultType,
                                  Program.ResultType)))),
       message (ERROR, "return value required", 0, COORDREF))
       <- INCLUDING Program.TypeIsSet;
     END;
     
     SYMBOL Program COMPUTE
       SYNT.ResultType = voidType;
     END;
     
     RULE: Function ::= FunctionHead Block COMPUTE
       Function.ResultType = FunctionHead.ResultType;
     END;
     
     RULE: FunctionHead ::= '(' Parameters ')' TypeDenoter COMPUTE
       FunctionHead.ResultType = TypeDenoter.Type;
     END;

     This macro is invoked in definition 100.

Function.lido[100]==
     Abstract function syntax[91]
     Abstract call syntax[96]
     Function declaration types[93]
     Function range[92]
     Function type[94]
     Function signature[95]
     Call types[97]
     Arguments[98]
     Return statements[99]

     This macro is attached to a product file.

Function.con[101]==
     Function declaration syntax[140]
     Call syntax[141]

     This macro is attached to a product file.


File: typetutorial,  Node: Type3,  Next: Pointer,  Prev: Functions,  Up: Top

Type Definitions
****************

This chapter introduces type definitions to the language.  A name can
be defined for any `TypeDenoter' and can be used to denote that type.

Here is an example program with type definitions. It makes use of the
facility that identifiers may be defined after their uses:

TypedefExamp[102]==
     begin
       var   tt rv;
       type  t tt;
       type  record int i, bool b, real r end t;
       var   int j, bool c, real s;
       var   t rt;
       j = rv.i;
       c = rv.b;
       s = rv.r;
       rt = rv;
     end

     This macro is attached to a product file.

The following productions are added to the grammar:

Abstract type declaration syntax[103]==
     RULE: Declaration  ::= 'type' TypeDenoter TypeDefIdent ';' END;
     RULE: TypeDefIdent ::= Ident END;
     
     RULE: TypeDenoter  ::= TypeUseIdent END;
     RULE: TypeUseIdent ::= Ident END;

     This macro is invoked in definition 113.

A type definition introduces a new name for a type given by the
`TypeDenoter'. We distinguish between defining occurrences
`TypeDefIdent' used occurrences `TypeUseIdent' of type names.

In our language we specify that a type definition does not introduce a
new type, rather it introduces another name for a type. Hence, there
may be many different names for the same type. Furthermore, even two
`TypeDenoter' that differ in certain aspects may denote the same type. 
This view can be supported by the roles of the `StructEquiv' module:
For each kind of types it is stated which of its properties
distinguish two types of that kind (see record types or array types).

Hence, in the following specification we only have to characterize a
defining occurrence of a type identifier by the corresponding roles of
the name analysis module and those for a defining occurrence of a type
identifier (`TypeDefDefId', `ChkTypeDefDefId'). In the `Declaration'
context the `Type' attribute is just passed from the `TypeDenoter' to
the `TypeDefIdent'.

Type declaration computation[104]==
     SYMBOL TypeDefIdent INHERITS
             ChkUnique, IdDefScope, IdentOcc,
             TypeDefDefId, ChkTypeDefDefId
     END;
     
     RULE: Declaration ::= 'type' TypeDenoter TypeDefIdent ';' COMPUTE
       TypeDefIdent.Type = TypeDenoter.Type;
     END;

     This macro is invoked in definition 113.

Used occurrences of type identifiers are characterized by the module
roles `TypeDefUseId' and `ChkTypeDefUseId', and by the roles that
characterize used indentifier occurrences of any kind:

Used type identifiers[105]==
     SYMBOL TypeUseIdent INHERITS
        IdUseEnv, IdentOcc, ChkIdUse,
        TypeDefUseId, ChkTypeDefUseId END;
     
     RULE: TypeDenoter ::= TypeUseIdent COMPUTE
       TypeDenoter.Type = TypeUseIdent.Type;
     END;

     This macro is invoked in definition 113.

A language that has facilities to define names for types and allows
identifier uses before their definitions, opens the possibility to
define types recursively, e.g.
       type record int i, rt x end rt;
In many languages such a type `rt' would be disallowed, because a
value of type `rt' may not contain another value of the same type.
However, if the type of the component `x' was defined to be `pointer
to rt' instead of `rt', then a useful list type would be defined.

This example illustrates that the existence of type definitions may
cause the need to specify  which recursive type definitions are
considered legal for a certain language.  In our language, as defined
so far, any recursion in a type definition is considered to be
disallowed.  However, the situation changes when there are types, like
pointer types, such that that recursion is allowed when it passes
through such a type.

Hence, we introduce three properties: `IsRecursiveType',
`IsNotRecursiveType' indicates whether a type is illegally recursive. 
`AllowRecurType' indicates that recursion through such a type is
allowed. The latter will be set when such types are introduced, i.e.
in the chapter on pointer types: Check recursive types
properties[106]==
     IsRecursiveType: int;
     IsNotRecursiveType: int;
     AllowRecurType: int;

     This macro is invoked in definition 112.

Such a check is performed by a function `ChkRecursiveType' which is
applied to a type `t' and recursively walks through the component
types of `t'. If it reaches `t' again (without having passed through a
type that allows recursion), the type is indicated to be illegally
recursive.

Check for recursive types[107]==
     SYMBOL TypeDefIdent COMPUTE
       IF (ChkRecursiveType (THIS.Type),
         message (ERROR, CatStrInd ("Recursively defined type: ",
                                    THIS.Sym),
                  0, COORDREF))
         <- INCLUDING Program.GotAllTypes;
     END;

     This macro is invoked in definition 113.

The implementation of the type walk algorithm uses a property that
indicates whether a type is currently visited by the algorithm:
Visiting property[108]==
     Visiting: int;

     This macro is invoked in definition 112.

The following C module implements an algorithm that walks recursively
through the components of a type to check whether the type is defined
illegally recursively.

RecTypeChk.head[109]==
     #include "RecTypeChk.h"

     This macro is attached to a product file.

RecTypeChk.h[110]==
     #include "deftbl.h"
     extern int ChkRecursiveType (DefTableKey tp);

     This macro is attached to a product file.

RecTypeChk.c[111]==
     #include "pdl_gen.h"
     #include "StructEquiv.h"
     #include "Typing.h"
     
     #ifdef TEST
     #define TEST 1
     #include <stdio.h>
     #endif
     
     static DefTableKey origType;
     
     
     int VisitCompOfType (DefTableKey node, DefTableKey component)
     /* This is the function used by the type walk that checks
        for recursive types. It is called for every visit from a type node
        to one of its components. 5 cases are distinguished, as explained below:
     */
     {
     #ifdef TEST
       printf ("visit at %s (%d) component %s (%d)\n",
           GetTypeName (node, "no name"),
           GetTypeLine (node, 0),
           GetTypeName (component, "no name"),
           GetTypeLine (component, 0));
     #endif
       if (GetAllowRecurType (component, 0))
          /* do not visit a component type that allows recursion */
          return 1;
       else {
          if (FinalType (component) == FinalType (origType)) {
            /* the type under investigation contains itself on a path
               that does not lead through a type which allows for
               recursion
            */
            ResetIsRecursiveType (origType, 1);
            ResetIsRecursiveType (component, 1);
            return 2; /* terminate walk */
          }
          if (GetIsRecursiveType (component, 0)) {
          /* The component type of the node is already
             recognized to be recursive
          */
             ResetIsRecursiveType (origType, 1);
             return 2; /* terminate walk */
          }
          if (GetVisiting (component, 0)) {
            /* This component lies on a non-pointer cycle
               not involving the original type under investigation
            */
            ResetIsRecursiveType (origType, 1);
            ResetIsRecursiveType (component, 1);
            return 2; /* terminate walk */
          }
       }
       return 0; /* visit this component */
     }
     
     int RecWalkType (DefTableKey currType)
     /*
          Every direct or indirect component type of tp is visited, unless
          the call VisitCompOfType (curr, comp) shortcuts the walk.
          If it returns
            0: comp is visited
            1: comp is skipped
            2: the walk is terminated
     */
     { DefTableKeyList compseq;
       DefTableKey compType;
       int visitRes;
       currType = FinalType (currType);
     
       /* Do not visit a node, that is currently visited: */
       if (GetVisiting (currType, 0)) return 1;
       ResetVisiting (currType, 1);
     
       /* consider all component types: */
       for (compseq = GetComponentTypes (currType, NULLDefTableKeyList);
            compseq != NULLDefTableKeyList;
            compseq = TailDefTableKeyList (compseq)) {
          compType = FinalType (HeadDefTableKeyList (compseq));
     
          /* Skip non-type: */
          if (compType == NoKey) continue;
     
          /* Visit this component: */
          visitRes = VisitCompOfType (currType, compType);
     
          /* The component visit indicates how to continue: */
          switch (visitRes) {
            case 0:            /* dive into the component */
               if (RecWalkType (compType)) {
                  /* the type walk is to be terminated */
                  visitRes = 2;
                  goto ret;
               };
               break;
            case 1:            /* do not dive into the component */
               break;
            case 2:            /* terminate the walk */
               visitRes = 2;
               goto ret;
            default:;
            }
            /* iteration of components continues */
          }
          visitRes = 0; /* components elaborated */
     ret:
       ResetVisiting (currType, 0);
       return visitRes;
     }
     
     
     int ChkRecursiveType (DefTableKey tp)
     /* on entry:
          The results of the type equivalence analysis must be computed and
          stored in the type data base.
          tp represents a type.
        method:
          A walk through the type structure of tp is initiated,
          and then executed.
          VisitCompOfType (curr, comp) is called whenever
          a direct component comp of the type curr is visited.
          origType stores the type for which the recursion check is initiated.
          Every type that is found to be illegally recursive is marked by
          the property IsRecursiveType. It is also used to shortcut
          the walk through the type structure.
        on exit:
          1 is returned if the type tp directly or indirectly
          has tp as a component type, and the path to it is not
          legal for recursion
          0 is returned otherwise.
     */
     {
       tp = FinalType (tp);
       origType = tp;
       if (GetIsRecursiveType (tp, 0)) return 1;
       if (GetIsNotRecursiveType (tp, 0)) return 0;
     
       /* the result is not yet known: */
       RecWalkType (tp);
     
       return GetIsRecursiveType (tp, 0);
     }

     This macro is attached to a product file.

TypeDef.pdl[112]==
     Check recursive types properties[106]
     Visiting property[108]

     This macro is attached to a product file.

TypeDef.lido[113]==
     Abstract type declaration syntax[103]
     Type declaration computation[104]
     Used type identifiers[105]
     Check for recursive types[107]

     This macro is attached to a product file.


File: typetutorial,  Node: Pointer,  Next: Function,  Prev: Type3,  Up: Top

Pointer Types
*************

In this chapter we introduce pointer types to our language.  The
notation `t !' denotes a type for values that point to values of type
`t'.

A new `Variable' notation is introduced: In `v !' the dereferencing
operator `!' is applied to the variable `v', which must have a pointer
type. The result of the operation is the value that `v' points to.

A pointer value of type `t !' is created by execution of a generator
`new t', where `t' is a type denotation.

Here is an example program that uses these pointer constructs in
different contexts:

PointerExamp[114]==
     begin
       var   int k;
       var   int! pi, int! pj;
       var   record int i, bool b, real! r end! rv;
       type  record int x, t! next end t;
       var   t l;
       pi = new int;
       pi! = 1;
       pi = pj;
       pi! = pj!;
       rv!.b = true;
       rv!.r! = 3.2;
       l.next!.x = 1;
       l.next = nil;
     end

     This macro is attached to a product file.

The following productions are added to the grammar:

Abstract pointer syntax[115]==
     RULE: TypeDenoter ::= PointerType END;
     RULE: PointerType ::= TypeDenoter '!' END;
     
     RULE: Variable    ::= Variable '!' END;
     RULE: Expression  ::= 'nil' END;
     RULE: Expression  ::= Generator END;
     RULE: Generator   ::= 'new' TypeDenoter END;

     This macro is invoked in definition 125.

There are two constructs which introduce a pointer type.  The first
one is a denoter for a pointer type. Two monadic operators are created
for each pointer type: One is applied to a pointer and yields the
value pointed to, the other yields the reference of an entity instead
of its value. The dereferencing operators of all pointer types are
overloaded on the indication `DerefOpr', correspondingly all operators
that prevent dereferencing are overloaded on the indication `RefOpr'. 
We also introduce an artificial type for the `nil' symbol: Pointer
operators[116]==
     DerefOpr;
     RefOpr;
     NilOpr;
     nilType -> IsType = {1};

     This macro is invoked in definition 124.

Creating these pairs of operators for a pointer type establishes the
condition `PointerType.GotOper', which is a precondition for operator
identification. Furthermore, we state that the type of the `nil'
symbol is coercible to each pointer type.

Pointer type denotation[117]==
     RULE: TypeDenoter ::= PointerType COMPUTE
       TypeDenoter.Type = PointerType.Type;
     END;
     
     SYMBOL PointerType INHERITS TypeDenotation, OperatorDefs END;
     
     RULE: PointerType ::= TypeDenoter '!' COMPUTE
       PointerType.GotOper +=
         ORDER
           (Coercible (NilOpr, nilType, PointerType.Type),
            MonadicOperator
              (DerefOpr, NewKey(), PointerType.Type, TypeDenoter.Type),
            MonadicOperator
              (RefOpr, NewKey(), TypeDenoter.Type, PointerType.Type));
     END;
     
     RULE: Expression  ::= 'nil' COMPUTE
       PrimaryContext (Expression, nilType);
     END;

     This macro is invoked in definition 125.

A generator also introduces a pointer type. The `TypeDenoter' states
which is the type pointed to.  Generators may occur as operand in
expressions:

Generator[118]==
     SYMBOL Generator INHERITS TypeDenotation, OperatorDefs END;
     
     RULE: Generator ::= 'new' TypeDenoter COMPUTE
       Generator.GotOper +=
         ORDER (
         MonadicOperator
            (DerefOpr, NewKey(), Generator.Type, TypeDenoter.Type),
         MonadicOperator
            (RefOpr, NewKey(), TypeDenoter.Type, Generator.Type));
     END;
     
     RULE: Expression ::= Generator COMPUTE
       PrimaryContext (Expression, Generator.Type);
     END;

     This macro is invoked in definition 125.

Types `t !', `s !' and the types created by `new t' and `new s' are
all considered to be equivalent in our language, if the types `s' and
`t' are equivalent, with respect to renaming and to equivalence rules
for the particular type categories.

We use the facilities of the `StructEquiv' module to specify such
structural type equivalence for pointer types.  In particular two
conditions are specified for types `a' and `b' to be equivalent: Both
have to be of the kind `PointerClass', and their sequences of
component types have to be elementwise equivalent, in this case the
single type pointed to: EqualPtrTypes.lido[119]==
     RULE: PointerType ::= TypeDenoter '!' COMPUTE
       PointerType.GotType =
         AddTypeToBlock
           (PointerType.Type, PointerClass,
            VResetComponentTypes
              (PointerType.Type, SingleDefTableKeyList (TypeDenoter.Type)))
       <- .moreTypeProperies;
     END;
     
     RULE: Generator ::= 'new' TypeDenoter COMPUTE
       Generator.GotType =
         AddTypeToBlock
           (Generator.Type, PointerClass,
            VResetComponentTypes
              (Generator.Type, SingleDefTableKeyList (TypeDenoter.Type)))
       <- .moreTypeProperies;
     END;

     This macro is attached to a product file.

The `PointerClass' is a unique key used to distinguish this kind of
types from other kinds, e.g. array types:

Pointer type equality[120]==
     PointerClass;

     This macro is invoked in definition 124.

Pointer types are to be treated especially when types are checked for
equivalence: On the one hand, a type is allowed to be recursively
defined if the recursion goes through a pointer component, for example
in `type record int i, rec! p end rec;'.  That is why we associate the
property `AllowRecurType' to the pointer type, together with the
properties defining the output for types.

Pointer types allow recursion[121]==
     RULE: PointerType ::= TypeDenoter '!' COMPUTE
       .moreTypeProperies =
         ORDER
           (ResetTypeName (PointerType.Type, "pointer..."),
            ResetTypeLine (PointerType.Type, LINE),
            ResetAllowRecurType (PointerType.Type, 1));
     END;
     
     RULE: Generator ::= 'new' TypeDenoter COMPUTE
       .moreTypeProperies =
         ORDER
           (ResetTypeName (Generator.Type, "pointer..."),
            ResetTypeLine (Generator.Type, LINE),
            ResetAllowRecurType (Generator.Type, 1));
     END;

     This macro is invoked in definition 125.

On the other hand, we have to check that pointer types are not defined
directly recursively, or indirectly recursively s.t.  only pointer
types are involved:
       type p1! p1;
       type p2! p3;
       type p3! p2;
In the example above all three type are pairwise equivalent.

Recursion check for pointer types[122]==
     RULE: PointerType ::= TypeDenoter '!' COMPUTE
       IF (EQ (FinalType (PointerType.Type), FinalType (TypeDenoter.Type)),
         message (ERROR, "Recursively defined pointer type",
                  0, COORDREF))
         <- INCLUDING Program.TypeIsSet;
     END;

     This macro is invoked in definition 125.

For the dereferencing operation applied to a `Variable' we specify
that in the following context a suitable operator that overloads the
`DerefOpr' indication is applicable:

Pointer variable[123]==
     RULE: Variable ::= Variable '!' COMPUTE
       MonadicContext (Variable[1], , Variable[2]);
       Indication (DerefOpr);
     
       IF(BadOperator,
         message(ERROR,"Dereferencing not allowed", 0, COORDREF));
     END;

     This macro is invoked in definition 125.

Pointer.pdl[124]==
     Pointer type equality[120]
     Pointer operators[116]

     This macro is attached to a product file.

Pointer.lido[125]==
     Abstract pointer syntax[115]
     Pointer type denotation[117]
     Generator[118]
     Pointer types allow recursion[121]
     Recursion check for pointer types[122]
     Pointer variable[123]

     This macro is attached to a product file.

Pointer.con[126]==
     Concrete pointer syntax[143]

     This macro is attached to a product file.


File: typetutorial,  Node: Function,  Next: Appendix,  Prev: Pointer,  Up: Top

Function Types
**************

We finally extend our language towards the orthogonal use of
functions, i.e. wherever a typed entity is allowed it can have a
function type. In particular, evaluation of an expression may yield a
function, which may be called, assigned to a variable, passed as an
argument, or returned as a function result.  For that purpose it is
sufficient to add another `TypeDenoter' which denotes function types.
New notations for expressions are not needed.

Here is an example program that defines a function type and a higher
order function:

FctTypeExamp[127]==
     begin
       fun mul (int x, real y) real
       begin return x * y; end;
     
       fun add (int x, real y) real
       begin return x + y; end;
     
       type (int, real -> real) fct;
     
       fun apply2 (real z, fct ff) real
       begin return ff (2, z); end;
     
       var real r;
     
       r = apply2 (3.1, add);
       r = apply2 (3.1, mul);
     end

     This macro is attached to a product file.

The following productions are added to the grammer:

Abstract function type syntax[128]==
     RULE: TypeDenoter  ::=    FunctionType END;
     RULE: FunctionType ::=    '(' ParamTypes '->' TypeDenoter ')' END;
     RULE: ParamTypes   LISTOF ParamType END;
     RULE: ParamType    ::=    TypeDenoter END;

     This macro is invoked in definition 133.

The specifications for `FunctionType's exactly correspond to those for
`FunctionHead's in the context of function declarations. An Operator
is created, that has a signature as given by the types of the
parameters and of the result:

Function type denotation[129]==
     RULE: TypeDenoter ::= FunctionType COMPUTE
       TypeDenoter.Type = FunctionType.Type;
     END;
     
     SYMBOL FunctionType INHERITS TypeDenotation, OperatorDefs END;
     
     RULE: FunctionType ::= '(' ParamTypes '->' TypeDenoter ')' COMPUTE
       FunctionType.GotOper +=
          ListOperator (
            FunctionType.Type,
            FunctionType.Type,
            ParamTypes.OpndTypeList,
            TypeDenoter.Type);
     
      .moreTypeProperies =
         ORDER
           (ResetTypeName (FunctionType.Type, "function..."),
            ResetTypeLine (FunctionType.Type, LINE));
     END;

     This macro is invoked in definition 133.

The introduction of function types to our language allows programs to
use values which represent functions. They have a function type which
must fit to the type required in the context.  For example, the
`apply2 (3.1, add)' passes the function `add' as an argument of the
called function `apply2'.  Hence, the type of the declared function
`add' must be equivalent to the type required for the second parameter
of `apply2' (or coercible under type rules for parameter, as specified
in the chapter on functions).

In this case we have to specify structural equivalence of function
types, in oder to let the type rules allow such uses of functions.  If
we would specify name equivalence instead, then for the above example,
the signature of the function declaration and the type `fct' specified
for the second parameter of `apply2' are different notations of types.
They would be considered not to be name equivalent; but, they are
structural equivalent.

Structural type equivalence is specified for denotations of function
types that either occur in a type denotation or as the signature of a
declared function.  We state that two types `a' and `b' are equivalent
if both have the kind `FunctionClass', and the component types, which
are the types of the parameters and of the result, are elementwise
equivalent:

Function type equivalence[130]==
     RULE: FunctionHead ::= '(' Parameters ')' TypeDenoter COMPUTE
       FunctionHead.GotType =
         ORDER (
           AddTypeToBlock (
              FunctionHead.Type, FunctionClass,
              VResetComponentTypes
                (FunctionHead.Type,
                 ConsDefTableKeyList
                   (TypeDenoter.Type, Parameters.OpndTypeList))),
              ResetTypeName (FunctionHead.Type, "function..."),
              ResetTypeLine (FunctionHead.Type, LINE));
     END;
     
     RULE: FunctionType ::= '(' ParamTypes '->' TypeDenoter ')' COMPUTE
       FunctionType.GotType =
         AddTypeToBlock
           (FunctionType.Type, FunctionClass,
              VResetComponentTypes
                (FunctionType.Type,
                 ConsDefTableKeyList
                  (TypeDenoter.Type, ParamTypes.OpndTypeList)))
       <- .moreTypeProperies;
     END;
     
     SYMBOL ParamTypes INHERITS OpndTypeListRoot END;
     SYMBOL ParamType INHERITS OpndTypeListElem END;
     
     RULE: ParamType ::= TypeDenoter COMPUTE
       ParamType.Type = TypeDenoter.Type;
     END;

     This macro is invoked in definition 133.

Function class[131]==
     FunctionClass;

     This macro is invoked in definition 132.

We require for our language, that a function type `f' may not directly
or indirectly have a component type `f', unless the recursion passes
through a pointer type. The check is specified in the context of type
definitions.

FunctionType.pdl[132]==
     Function class[131]

     This macro is attached to a product file.

FunctionType.lido[133]==
     Abstract function type syntax[128]
     Function type denotation[129]
     Function type equivalence[130]

     This macro is attached to a product file.

FunctionType.con[134]==
     Function type syntax[142]

     This macro is attached to a product file.


File: typetutorial,  Node: Appendix,  Prev: Function,  Up: Top

Appendix: Syntax
****************

* Menu:

* Concrete:: Concrete Kernel Syntax.
* Concrete1:: Concrete Expression Syntax.
* Concrete2:: Concrete Function Syntax.
* Other:: Other concrete productions.


File: typetutorial,  Node: Concrete,  Next: Concrete1,  Up: Appendix

Concrete Kernel Syntax
======================

Concrete Kernel syntax[135]==
     Declarations:   Declaration*.
     Declaration:    'var' ObjDecls ';'.
     ObjDecls:       [ObjDecl // ','].
     Statements:     Statement*.
     
     Expression:     Factor.
     Factor:         Operand.
     Operand:        IntNumber.
     Operand:        RealNumber.
     Operand:        'true'.
     Operand:        'false'.
     Operand:        Variable.

     This macro is invoked in definition 18.

The expression syntax is prepared to introduce operators of different
precedences (2 for binary and 1 for unary operators).

`Factor' and `Operand' are represented by `Expression' contexts in the
tree grammar:

Expression mapping[136]==
     Expression ::= Factor Operand.

     This macro is invoked in definition 19.

The notation of identifiers, numbers, and comments is chosen as in
Pascal:

Token notation[137]==
     Ident:          PASCAL_IDENTIFIER
     IntNumber:      PASCAL_INTEGER
     RealNumber:     PASCAL_REAL
                     PASCAL_COMMENT

     This macro is invoked in definition 17.


File: typetutorial,  Node: Concrete1,  Next: Concrete2,  Prev: Concrete,  Up: Appendix

Concrete Expression Syntax
==========================

Expression syntax[138]==
     Expression:     Expression AddOpr Factor.
     Factor:         Factor MulOpr Operand.
     Operand:        MonOpr Operand.
     Operand:        '(' Expression ')'.
     AddOpr:         '+' / '-'.
     MulOpr:         '*' / '/'.
     MonOpr:         '+' / '-' / '!'.

     This macro is invoked in definition 32.

The following specification unifies the binary operators that have
different precedences into one symbol class `BinOpr' of the abstract
syntax.

Operators[139]==
     BinOpr ::= AddOpr MulOpr.
     UnOpr ::= MonOpr.

     This macro is invoked in definition 33.


File: typetutorial,  Node: Concrete2,  Next: Other,  Prev: Concrete1,  Up: Appendix

Concrete Function Syntax
========================

Function declaration syntax[140]==
     Parameters:     [Parameter // ','].

     This macro is invoked in definition 101.

Call syntax[141]==
     Arguments:      [Argument // ','].

     This macro is invoked in definition 101.

Function type syntax[142]==
     ParamTypes:     [ParamType // ','].

     This macro is invoked in definition 134.


File: typetutorial,  Node: Other,  Prev: Concrete2,  Up: Appendix

Other concrete productions
==========================

Concrete pointer syntax[143]==
     Operand: 'nil'.

     This macro is invoked in definition 126.

Concrete notations are stated for the comma separated sequence of type
denoters. The specific precedence of the cast expression and its
parentheses avoid a parsing conflict.  Concrete union syntax[144]==
     UnitedTypes: UnitedTypes ',' UnitedType.
     UnitedTypes: UnitedType.
     Operand: '<' TypeDenoter '>' Operand.

     This macro is invoked in definition 89.


